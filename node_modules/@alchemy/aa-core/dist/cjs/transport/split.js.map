{"version":3,"file":"split.js","sourceRoot":"","sources":["../../../src/transport/split.ts"],"names":[],"mappings":";;;AAAA,+BAAoE;AA0C7D,MAAM,KAAK,GAAG,CAAC,MAA4B,EAAmB,EAAE;IACrE,MAAM,WAAW,GAAG,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE;QAC1D,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;YAC9B,IAAI,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,IAAI,CAAC,SAAS,EAAE,CAAC;gBAC9D,MAAM,IAAI,KAAK,CACb,uDAAuD,CACxD,CAAC;YACJ,CAAC;YAED,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;QACpC,CAAC,CAAC,CAAC;QAEH,OAAO,KAAK,CAAC;IACf,CAAC,EAAE,IAAI,GAAG,EAAqB,CAAC,CAAC;IAEjC,OAAO,CAAC,IAAI,EAAE,EAAE,CACd,IAAA,aAAM,EAAC;QACL,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE;YACtB,MAAM,iBAAiB,GAAG,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACvD,IAAI,iBAAiB,IAAI,IAAI,EAAE,CAAC;gBAC9B,OAAO,iBAAiB,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC/C,CAAC;YAED,OAAO,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QAC7C,CAAC;KACF,CAAC,CAAC,IAAI,CAAC,CAAC;AACb,CAAC,CAAC;AA1BW,QAAA,KAAK,SA0BhB","sourcesContent":["import { custom, type CustomTransport, type Transport } from \"viem\";\n\nexport interface SplitTransportParams {\n  overrides: {\n    methods: string[];\n    transport: Transport;\n  }[];\n  fallback: Transport;\n}\n\n/**\n * The Split Transport allows you to split RPC traffic for specific methods across\n * different RPC providers. This is done by specifying the methods you want handled\n * specially as overrides and providing a fallback transport for all other methods.\n *\n * @example\n * ```ts\n * import { createPublicClient, http } from \"viem\";\n * import { split } from \"@alchemy/aa-core\";\n *\n * const bundlerMethods = [\n *  \"eth_sendUserOperation\",\n *  \"eth_estimateUserOperationGas\",\n *  \"eth_getUserOperationReceipt\",\n *  \"eth_getUserOperationByHash\",\n *  \"eth_supportedEntryPoints\"\n * ];\n *\n * const clientWithSplit = createPublicClient({\n *  transport: split({\n *      overrides: [{\n *          methods: bundlerMethods,\n *          transport: http(BUNDLER_RPC_URL)\n *      }]\n *      fallback: http(OTHER_RPC_URL)\n *  }),\n * });\n * ```\n *\n * @param params {@link SplitTransportParams} split transport configuration containing the methods overrides and fallback transport\n * @returns a {@link CustomTransport} that splits traffic\n */\nexport const split = (params: SplitTransportParams): CustomTransport => {\n  const overrideMap = params.overrides.reduce((accum, curr) => {\n    curr.methods.forEach((method) => {\n      if (accum.has(method) && accum.get(method) !== curr.transport) {\n        throw new Error(\n          \"A method cannot be handled by more than one transport\"\n        );\n      }\n\n      accum.set(method, curr.transport);\n    });\n\n    return accum;\n  }, new Map<string, Transport>());\n\n  return (opts) =>\n    custom({\n      request: async (args) => {\n        const transportOverride = overrideMap.get(args.method);\n        if (transportOverride != null) {\n          return transportOverride(opts).request(args);\n        }\n\n        return params.fallback(opts).request(args);\n      },\n    })(opts);\n};\n"]}