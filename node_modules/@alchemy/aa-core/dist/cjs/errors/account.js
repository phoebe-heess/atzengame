"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartAccountWithSignerRequiredError = exports.IncorrectAccountType = exports.UpgradeToAndCallNotSupportedError = exports.AccountRequiresOwnerError = exports.BatchExecutionNotSupportedError = exports.FailedToGetStorageSlotError = exports.SignTransactionNotSupportedError = exports.UpgradesNotSupportedError = exports.GetCounterFactualAddressError = exports.DefaultFactoryNotDefinedError = exports.AccountNotFoundError = void 0;
const base_js_1 = require("./base.js");
class AccountNotFoundError extends base_js_1.BaseError {
    constructor() {
        super("Could not find an Account to execute with this Action.");
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AccountNotFoundError"
        });
    }
}
exports.AccountNotFoundError = AccountNotFoundError;
class DefaultFactoryNotDefinedError extends base_js_1.BaseError {
    constructor(accountType, chain, version) {
        super([
            `No default factory for ${accountType} found on chain ${chain.name} for entrypoint version ${version}`,
            "Supply an override via the `factoryAddress` parameter when creating an account",
        ].join("\n"));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DefaultFactoryNotDefinedError"
        });
    }
}
exports.DefaultFactoryNotDefinedError = DefaultFactoryNotDefinedError;
class GetCounterFactualAddressError extends base_js_1.BaseError {
    constructor() {
        super("getCounterFactualAddress failed");
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "GetCounterFactualAddressError"
        });
    }
}
exports.GetCounterFactualAddressError = GetCounterFactualAddressError;
class UpgradesNotSupportedError extends base_js_1.BaseError {
    constructor(accountType) {
        super(`Upgrades are not supported by ${accountType}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UpgradesNotSupported"
        });
    }
}
exports.UpgradesNotSupportedError = UpgradesNotSupportedError;
class SignTransactionNotSupportedError extends base_js_1.BaseError {
    constructor() {
        super(`SignTransaction is not supported by smart contracts`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SignTransactionNotSupported"
        });
    }
}
exports.SignTransactionNotSupportedError = SignTransactionNotSupportedError;
class FailedToGetStorageSlotError extends base_js_1.BaseError {
    constructor(slot, slotDescriptor) {
        super(`Failed to get storage slot ${slot} (${slotDescriptor})`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FailedToGetStorageSlotError"
        });
    }
}
exports.FailedToGetStorageSlotError = FailedToGetStorageSlotError;
class BatchExecutionNotSupportedError extends base_js_1.BaseError {
    constructor(accountType) {
        super(`Batch execution is not supported by ${accountType}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "BatchExecutionNotSupportedError"
        });
    }
}
exports.BatchExecutionNotSupportedError = BatchExecutionNotSupportedError;
class AccountRequiresOwnerError extends base_js_1.BaseError {
    constructor(accountType) {
        super(`Account of type ${accountType} requires an owner to execute`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AccountRequiresOwnerError"
        });
    }
}
exports.AccountRequiresOwnerError = AccountRequiresOwnerError;
class UpgradeToAndCallNotSupportedError extends base_js_1.BaseError {
    constructor(accountType) {
        super(`UpgradeToAndCall is not supported by ${accountType}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UpgradeToAndCallNotSupportedError"
        });
    }
}
exports.UpgradeToAndCallNotSupportedError = UpgradeToAndCallNotSupportedError;
class IncorrectAccountType extends base_js_1.BaseError {
    constructor(expected, actual) {
        super(`Expected account type ${expected}, got ${actual}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IncorrectAccountTypeError"
        });
    }
}
exports.IncorrectAccountType = IncorrectAccountType;
class SmartAccountWithSignerRequiredError extends base_js_1.BaseError {
    constructor() {
        super("Smart account requires a signer");
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SmartAccountWithSignerRequiredError"
        });
    }
}
exports.SmartAccountWithSignerRequiredError = SmartAccountWithSignerRequiredError;
//# sourceMappingURL=account.js.map