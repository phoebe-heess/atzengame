"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBundlerClient = exports.createBundlerClientFromExisting = void 0;
const viem_1 = require("viem");
const client_js_1 = require("../errors/client.js");
const version_js_1 = require("../version.js");
const bundlerClient_js_1 = require("./decorators/bundlerClient.js");
const createBundlerClientFromExisting = (client) => {
    return client.extend(bundlerClient_js_1.bundlerActions);
};
exports.createBundlerClientFromExisting = createBundlerClientFromExisting;
function createBundlerClient(args) {
    if (!args.chain) {
        throw new client_js_1.ChainNotFoundError();
    }
    const { key = "bundler-public", name = "Public Bundler Client", type = "bundlerClient", } = args;
    const { transport, ...opts } = args;
    const resolvedTransport = transport({
        chain: args.chain,
        pollingInterval: opts.pollingInterval,
    });
    const baseParameters = {
        ...args,
        key,
        name,
        type,
    };
    const client = (() => {
        if (resolvedTransport.config.type === "http") {
            const { url, fetchOptions: fetchOptions_ } = resolvedTransport.value;
            const fetchOptions = fetchOptions_ ?? {};
            if (url.toLowerCase().indexOf("alchemy") > -1) {
                fetchOptions.headers = {
                    ...fetchOptions.headers,
                    "Alchemy-AA-Sdk-Version": version_js_1.VERSION,
                };
            }
            return (0, viem_1.createClient)({
                ...baseParameters,
                transport: (0, viem_1.http)(url, {
                    ...resolvedTransport.config,
                    fetchOptions,
                }),
            });
        }
        return (0, viem_1.createClient)(baseParameters);
    })();
    return client.extend(viem_1.publicActions).extend(bundlerClient_js_1.bundlerActions);
}
exports.createBundlerClient = createBundlerClient;
//# sourceMappingURL=bundlerClient.js.map