"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSmartAccountClientFromExisting = exports.createSmartAccountClient = void 0;
const viem_1 = require("viem");
const account_js_1 = require("../errors/account.js");
const client_js_1 = require("../errors/client.js");
const actions_js_1 = require("../middleware/actions.js");
const bundlerClient_js_1 = require("./bundlerClient.js");
const smartAccountClient_js_1 = require("./decorators/smartAccountClient.js");
const schema_js_1 = require("./schema.js");
function createSmartAccountClient(config) {
    const { key = "account", name = "account provider", transport, type = "SmartAccountClient", ...params } = config;
    const client = (0, bundlerClient_js_1.createBundlerClient)({
        ...params,
        key,
        name,
        type: "SmartAccountClient",
        transport: (opts) => {
            const rpcTransport = transport(opts);
            return (0, viem_1.custom)({
                async request({ method, params }) {
                    switch (method) {
                        case "eth_accounts": {
                            if (!client.account) {
                                throw new account_js_1.AccountNotFoundError();
                            }
                            return [client.account.address];
                        }
                        case "eth_sendTransaction":
                            if (!client.account) {
                                throw new account_js_1.AccountNotFoundError();
                            }
                            if (!client.chain) {
                                throw new client_js_1.ChainNotFoundError();
                            }
                            const [tx] = params;
                            return client.sendTransaction({
                                ...tx,
                                account: client.account,
                                chain: client.chain,
                            });
                        case "eth_sign":
                            if (!client.account) {
                                throw new account_js_1.AccountNotFoundError();
                            }
                            const [address, data] = params;
                            if (address !== client.account.address) {
                                throw new Error("cannot sign for address that is not the current account");
                            }
                            return client.signMessage(data);
                        case "personal_sign": {
                            if (!client.account) {
                                throw new account_js_1.AccountNotFoundError();
                            }
                            const [data, address] = params;
                            if (address !== client.account.address) {
                                throw new Error("cannot sign for address that is not the current account");
                            }
                            return client.signMessage(data);
                        }
                        case "eth_signTypedData_v4": {
                            if (!client.account) {
                                throw new account_js_1.AccountNotFoundError();
                            }
                            const [address, dataParams] = params;
                            if (address !== client.account.address) {
                                throw new Error("cannot sign for address that is not the current account");
                            }
                            return client.signTypedData(dataParams);
                        }
                        case "eth_chainId":
                            if (!opts.chain) {
                                throw new client_js_1.ChainNotFoundError();
                            }
                            return opts.chain.id;
                        default:
                            return rpcTransport.request({ method, params });
                    }
                },
            })(opts);
        },
    })
        .extend(() => ({
        ...schema_js_1.SmartAccountClientOptsSchema.parse(config.opts ?? {}),
    }))
        .extend((0, actions_js_1.middlewareActions)(config))
        .extend(smartAccountClient_js_1.smartAccountClientActions);
    return { ...client, type };
}
exports.createSmartAccountClient = createSmartAccountClient;
function createSmartAccountClientFromExisting(config) {
    return createSmartAccountClient({
        ...config,
        chain: config.client.chain,
        transport: (0, viem_1.custom)(config.client),
    });
}
exports.createSmartAccountClientFromExisting = createSmartAccountClientFromExisting;
//# sourceMappingURL=smartAccountClient.js.map