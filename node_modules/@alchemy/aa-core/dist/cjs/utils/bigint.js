"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringToIndex = exports.bigIntMultiply = exports.RoundingMode = exports.bigIntClamp = exports.bigIntMin = exports.bigIntMax = void 0;
const viem_1 = require("viem");
const schema_js_1 = require("./schema.js");
const bigIntMax = (...args) => {
    if (!args.length) {
        throw new Error("bigIntMax requires at least one argument");
    }
    return args.reduce((m, c) => (m > c ? m : c));
};
exports.bigIntMax = bigIntMax;
const bigIntMin = (...args) => {
    if (!args.length) {
        throw new Error("bigIntMin requires at least one argument");
    }
    return args.reduce((m, c) => (m < c ? m : c));
};
exports.bigIntMin = bigIntMin;
const bigIntClamp = (value, lower, upper) => {
    lower = lower != null ? BigInt(lower) : null;
    upper = upper != null ? BigInt(upper) : null;
    if (upper != null && lower != null && upper < lower) {
        throw new Error(`invalid range: upper bound ${upper} is less than lower bound ${lower}`);
    }
    let ret = BigInt(value);
    if (lower != null && lower > ret) {
        ret = lower;
    }
    if (upper != null && upper < ret) {
        ret = upper;
    }
    return ret;
};
exports.bigIntClamp = bigIntClamp;
var RoundingMode;
(function (RoundingMode) {
    RoundingMode[RoundingMode["ROUND_DOWN"] = 0] = "ROUND_DOWN";
    RoundingMode[RoundingMode["ROUND_UP"] = 1] = "ROUND_UP";
})(RoundingMode || (exports.RoundingMode = RoundingMode = {}));
const bigIntMultiply = (base, multiplier, roundingMode = RoundingMode.ROUND_UP) => {
    if (!(0, schema_js_1.isMultiplier)({ multiplier })) {
        throw new Error("bigIntMultiply requires a multiplier validated number as the second argument");
    }
    const decimalPlaces = multiplier.toString().split(".")[1]?.length ?? 0;
    const val = roundingMode === RoundingMode.ROUND_UP
        ? BigInt(base) * BigInt(multiplier * 10 ** decimalPlaces) +
            BigInt(10 ** decimalPlaces - 1)
        : BigInt(base) * BigInt(multiplier * 10 ** decimalPlaces);
    return val / BigInt(10 ** decimalPlaces);
};
exports.bigIntMultiply = bigIntMultiply;
const stringToIndex = (phrase) => BigInt((0, viem_1.keccak256)((0, viem_1.toHex)(phrase)));
exports.stringToIndex = stringToIndex;
//# sourceMappingURL=bigint.js.map