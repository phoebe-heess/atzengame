"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.concatPaymasterAndData = exports.parsePaymasterAndData = exports.bypassPaymasterAndDataEmptyHex = exports.bypassPaymasterAndData = exports.applyUserOpOverrideOrFeeOption = exports.applyUserOpFeeOption = exports.applyUserOpOverride = exports.isValidFactoryAndData = exports.isValidPaymasterAndData = exports.isValidRequest = void 0;
const viem_1 = require("viem");
const bigint_js_1 = require("./bigint.js");
const index_js_1 = require("./index.js");
function isValidRequest(request) {
    return (BigInt(request.callGasLimit || 0n) > 0n &&
        BigInt(request.maxFeePerGas || 0n) > 0n &&
        BigInt(request.preVerificationGas || 0n) > 0n &&
        BigInt(request.verificationGasLimit || 0n) > 0n &&
        request.maxPriorityFeePerGas != null &&
        isValidPaymasterAndData(request) &&
        isValidFactoryAndData(request));
}
exports.isValidRequest = isValidRequest;
function isValidPaymasterAndData(request) {
    if ("paymasterAndData" in request) {
        return request.paymasterAndData != null;
    }
    return (0, index_js_1.allEqual)(request.paymaster == null, request.paymasterData == null, request.paymasterPostOpGasLimit == null, request.paymasterVerificationGasLimit == null);
}
exports.isValidPaymasterAndData = isValidPaymasterAndData;
function isValidFactoryAndData(request) {
    if ("initCode" in request) {
        const { initCode } = request;
        return initCode != null;
    }
    return (0, index_js_1.allEqual)(request.factory == null, request.factoryData == null);
}
exports.isValidFactoryAndData = isValidFactoryAndData;
function applyUserOpOverride(value, override) {
    if (override == null) {
        return value;
    }
    if ((0, index_js_1.isBigNumberish)(override)) {
        return override;
    }
    else {
        return value != null ? (0, bigint_js_1.bigIntMultiply)(value, override.multiplier) : value;
    }
}
exports.applyUserOpOverride = applyUserOpOverride;
function applyUserOpFeeOption(value, feeOption) {
    if (feeOption == null) {
        return value;
    }
    return value != null
        ? (0, bigint_js_1.bigIntClamp)(feeOption.multiplier
            ? (0, bigint_js_1.bigIntMultiply)(value, feeOption.multiplier)
            : value, feeOption.min, feeOption.max)
        : feeOption.min ?? 0n;
}
exports.applyUserOpFeeOption = applyUserOpFeeOption;
function applyUserOpOverrideOrFeeOption(value, override, feeOption) {
    return value != null && override != null
        ? applyUserOpOverride(value, override)
        : applyUserOpFeeOption(value, feeOption);
}
exports.applyUserOpOverrideOrFeeOption = applyUserOpOverrideOrFeeOption;
const bypassPaymasterAndData = (overrides) => !!overrides &&
    ("paymasterAndData" in overrides || "paymasterData" in overrides);
exports.bypassPaymasterAndData = bypassPaymasterAndData;
const bypassPaymasterAndDataEmptyHex = (overrides) => overrides !== undefined &&
    (("paymasterAndData" in overrides && overrides.paymasterAndData === "0x") ||
        ("paymasterData" in overrides && overrides.paymasterData === "0x"));
exports.bypassPaymasterAndDataEmptyHex = bypassPaymasterAndDataEmptyHex;
const parsePaymasterAndData = (paymasterAndData) => ({
    paymaster: paymasterAndData.substring(0, 42),
    paymasterData: `0x${paymasterAndData.substring(42)}`,
});
exports.parsePaymasterAndData = parsePaymasterAndData;
const concatPaymasterAndData = ({ paymaster = "0x", paymasterData = "0x", }) => (0, viem_1.concat)([paymaster, paymasterData]);
exports.concatPaymasterAndData = concatPaymasterAndData;
//# sourceMappingURL=userop.js.map