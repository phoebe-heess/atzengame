{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/utils/types.ts"],"names":[],"mappings":"","sourcesContent":["// borrowed from viem\n\n/**\n * @description Constructs a type by excluding `undefined` from `T`.\n *\n * @example\n * NoUndefined<string | undefined>\n * => string\n */\nexport type NoUndefined<T> = T extends undefined ? never : T;\n// borrowed from viem\n/**\n * @description Checks if {@link T} is `undefined`\n * @param T - Type to check\n * @example\n * type Result = IsUndefined<undefined>\n * //   ^? type Result = true\n */\n\nexport type IsUndefined<T> = [undefined] extends [T] ? true : false;\n\nexport type RequiredBy<TType, TKeys extends keyof TType> = Required<\n  Pick<TType, TKeys>\n> &\n  Omit<TType, TKeys>;\n\n/**\n * @description Combines members of an intersection into a readable type.\n *\n * @see {@link https://twitter.com/mattpocockuk/status/1622730173446557697?s=20&t=NdpAcmEFXY01xkqU3KO0Mg}\n * @example\n * Prettify<{ a: string } & { b: string } & { c: number, d: bigint }>\n * => { a: string, b: string, c: number, d: bigint }\n */\nexport type Prettify<T> = {\n  [K in keyof T]: T[K];\n} & {};\n\nexport type WithRequired<T, K extends keyof T> = Required<Pick<T, K>>;\nexport type WithOptional<T, K extends keyof T> = Pick<Partial<T>, K>;\n\n// Checks for type equivalence, evaluates always to either `true` or `false`.\n// Semantics: (EQ<A, B> = true) <==> (A <==> B)\nexport type EQ<A, B> = [A] extends [B]\n  ? [B] extends [A]\n    ? true\n    : false\n  : false;\n\n// Auxiliary type for `IsMemberOrSubtypeOfAComponent`\n// Evaluates to `true` or `boolean` if one of the explicit components (according to the TypeScript distribution\n// mechanism for union types) of the union type equals the other given type.\n// Examples:\n//    EqualsOneOfTheComponents<string, string | boolean> ⟶ boolean\n//    EqualsOneOfTheComponents<string, string> ⟶ true\n//    EqualsOneOfTheComponents<number, string | boolean> ⟶ false\nexport type EqualsOneOfTheComponents<T, Union> = Union extends infer Component // enforce distribution\n  ? EQ<T, Component>\n  : never;\n\n// Auxiliary type for `IsOneOf`\nexport type IsMemberOrSubtypeOfAComponent<\n  T,\n  Union,\n  ConjunctionOfExplicitComponentChecks extends boolean\n> = [T] extends [Union]\n  ? true extends ConjunctionOfExplicitComponentChecks\n    ? true\n    : false\n  : false;\n\n// Checks whether the given type equals one of the explicit components of the union type. Note that in this respect we\n// consider the members of the infinite types number and string as implicit since the inbuilt distribution mechanism of\n// TypeScript does not (cannot) distribute over the infinite number of strings or numbers. However, `boolean` is treated\n// by TypeScript (and accordingly here) as the explicit union `true | false`.\n//\n// In particular, the evaluation result is `false` if the type is a proper union of components of the union type. It also\n// evaluates to false if the given type is a proper subtype of one of its explicit components.\n// It always evaluates to either `true` or `false`.\n// Examples:\n//    IsOneOf<number, string | number | boolean> ⟶ true\n//    IsOneOf<2 | 4, 0 | 1 | 2 | 3 | 4 | 5 | 6> ⟶ false\n//    IsOneOf<'text', string> ⟶ false  // only implicit but not explicit component\nexport type IsOneOf<T, Union> = IsMemberOrSubtypeOfAComponent<\n  T,\n  Union,\n  EqualsOneOfTheComponents<T, Union>\n>;\n\nexport type OneOf<T1, T2> = IsOneOf<T1, T2> extends true ? T1 : never;\n\nexport type RecordableKeys<T> = {\n  [K in keyof T]: T[K] extends string | number | symbol ? K : never;\n}[keyof T];\n"]}