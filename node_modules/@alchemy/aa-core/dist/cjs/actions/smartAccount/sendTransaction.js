"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendTransaction = void 0;
const isSmartAccountClient_js_1 = require("../../client/isSmartAccountClient.js");
const account_js_1 = require("../../errors/account.js");
const client_js_1 = require("../../errors/client.js");
const transaction_js_1 = require("../../errors/transaction.js");
const useroperation_js_1 = require("../../errors/useroperation.js");
const buildUserOperationFromTx_js_1 = require("./buildUserOperationFromTx.js");
const sendUserOperation_js_1 = require("./internal/sendUserOperation.js");
const waitForUserOperationTransacation_js_1 = require("./waitForUserOperationTransacation.js");
async function sendTransaction(client, args, overrides, context) {
    const { account = client.account } = args;
    if (!account || typeof account === "string") {
        throw new account_js_1.AccountNotFoundError();
    }
    if (!args.to) {
        throw new transaction_js_1.TransactionMissingToParamError();
    }
    if (!(0, isSmartAccountClient_js_1.isBaseSmartAccountClient)(client)) {
        throw new client_js_1.IncompatibleClientError("BaseSmartAccountClient", "sendTransaction", client);
    }
    const uoStruct = await (0, buildUserOperationFromTx_js_1.buildUserOperationFromTx)(client, args, overrides, context);
    const { hash, request } = await (0, sendUserOperation_js_1._sendUserOperation)(client, {
        account: account,
        uoStruct,
        context,
        overrides,
    });
    return (0, waitForUserOperationTransacation_js_1.waitForUserOperationTransaction)(client, { hash }).catch((e) => {
        throw new useroperation_js_1.WaitForUserOperationError(request, e);
    });
}
exports.sendTransaction = sendTransaction;
//# sourceMappingURL=sendTransaction.js.map