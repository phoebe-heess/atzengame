"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForUserOperationTransaction = void 0;
const actions_1 = require("viem/actions");
const isSmartAccountClient_js_1 = require("../../client/isSmartAccountClient.js");
const client_js_1 = require("../../errors/client.js");
const transaction_js_1 = require("../../errors/transaction.js");
const logger_js_1 = require("../../logger.js");
const waitForUserOperationTransaction = async (client, args) => {
    if (!(0, isSmartAccountClient_js_1.isBaseSmartAccountClient)(client)) {
        throw new client_js_1.IncompatibleClientError("BaseSmartAccountClient", "waitForUserOperationTransaction", client);
    }
    const { hash, retries = {
        maxRetries: client.txMaxRetries,
        intervalMs: client.txRetryIntervalMs,
        multiplier: client.txRetryMultiplier,
    }, } = args;
    for (let i = 0; i < retries.maxRetries; i++) {
        const txRetryIntervalWithJitterMs = retries.intervalMs * Math.pow(retries.multiplier, i) +
            Math.random() * 100;
        await new Promise((resolve) => setTimeout(resolve, txRetryIntervalWithJitterMs));
        const receipt = await client
            .getUserOperationReceipt(hash)
            .catch((e) => {
            logger_js_1.Logger.error(`[SmartAccountProvider] waitForUserOperationTransaction error fetching receipt for ${hash}: ${e}`);
        });
        if (receipt) {
            return (0, actions_1.getTransaction)(client, {
                hash: receipt.receipt.transactionHash,
            }).then((x) => x.hash);
        }
    }
    throw new transaction_js_1.FailedToFindTransactionError(hash);
};
exports.waitForUserOperationTransaction = waitForUserOperationTransaction;
//# sourceMappingURL=waitForUserOperationTransacation.js.map