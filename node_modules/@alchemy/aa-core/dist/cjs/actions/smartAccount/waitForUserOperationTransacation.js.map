{"version":3,"file":"waitForUserOperationTransacation.js","sourceRoot":"","sources":["../../../../src/actions/smartAccount/waitForUserOperationTransacation.ts"],"names":[],"mappings":";;;AACA,0CAA8C;AAC9C,kFAAgF;AAChF,sDAAiE;AACjE,gEAA2E;AAC3E,+CAAyC;AAGlC,MAAM,+BAA+B,GAMxB,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,EAAE;IACzC,IAAI,CAAC,IAAA,kDAAwB,EAAC,MAAM,CAAC,EAAE,CAAC;QACtC,MAAM,IAAI,mCAAuB,CAC/B,wBAAwB,EACxB,iCAAiC,EACjC,MAAM,CACP,CAAC;IACJ,CAAC;IAED,MAAM,EACJ,IAAI,EACJ,OAAO,GAAG;QACR,UAAU,EAAE,MAAM,CAAC,YAAY;QAC/B,UAAU,EAAE,MAAM,CAAC,iBAAiB;QACpC,UAAU,EAAE,MAAM,CAAC,iBAAiB;KACrC,GACF,GAAG,IAAI,CAAC;IAET,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC,EAAE,EAAE,CAAC;QAC5C,MAAM,2BAA2B,GAC/B,OAAO,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC,CAAC;YACpD,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC;QAEtB,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAC5B,UAAU,CAAC,OAAO,EAAE,2BAA2B,CAAC,CACjD,CAAC;QAEF,MAAM,OAAO,GAAG,MAAM,MAAM;aACzB,uBAAuB,CAAC,IAAqB,CAAC;aAC9C,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE;YACX,kBAAM,CAAC,KAAK,CACV,qFAAqF,IAAI,KAAK,CAAC,EAAE,CAClG,CAAC;QACJ,CAAC,CAAC,CAAC;QAEL,IAAI,OAAO,EAAE,CAAC;YACZ,OAAO,IAAA,wBAAc,EAAC,MAAM,EAAE;gBAC5B,IAAI,EAAE,OAAO,CAAC,OAAO,CAAC,eAAe;aACtC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;QACzB,CAAC;IACH,CAAC;IAED,MAAM,IAAI,6CAA4B,CAAC,IAAI,CAAC,CAAC;AAC/C,CAAC,CAAC;AAjDW,QAAA,+BAA+B,mCAiD1C","sourcesContent":["import type { Chain, Client, Hex, Transport } from \"viem\";\nimport { getTransaction } from \"viem/actions\";\nimport { isBaseSmartAccountClient } from \"../../client/isSmartAccountClient.js\";\nimport { IncompatibleClientError } from \"../../errors/client.js\";\nimport { FailedToFindTransactionError } from \"../../errors/transaction.js\";\nimport { Logger } from \"../../logger.js\";\nimport type { WaitForUserOperationTxParameters } from \"./types.js\";\n\nexport const waitForUserOperationTransaction: <\n  TTransport extends Transport = Transport,\n  TChain extends Chain | undefined = Chain | undefined\n>(\n  client: Client<TTransport, TChain, any>,\n  args: WaitForUserOperationTxParameters\n) => Promise<Hex> = async (client, args) => {\n  if (!isBaseSmartAccountClient(client)) {\n    throw new IncompatibleClientError(\n      \"BaseSmartAccountClient\",\n      \"waitForUserOperationTransaction\",\n      client\n    );\n  }\n\n  const {\n    hash,\n    retries = {\n      maxRetries: client.txMaxRetries,\n      intervalMs: client.txRetryIntervalMs,\n      multiplier: client.txRetryMultiplier,\n    },\n  } = args;\n\n  for (let i = 0; i < retries.maxRetries; i++) {\n    const txRetryIntervalWithJitterMs =\n      retries.intervalMs * Math.pow(retries.multiplier, i) +\n      Math.random() * 100;\n\n    await new Promise((resolve) =>\n      setTimeout(resolve, txRetryIntervalWithJitterMs)\n    );\n\n    const receipt = await client\n      .getUserOperationReceipt(hash as `0x${string}`)\n      .catch((e) => {\n        Logger.error(\n          `[SmartAccountProvider] waitForUserOperationTransaction error fetching receipt for ${hash}: ${e}`\n        );\n      });\n\n    if (receipt) {\n      return getTransaction(client, {\n        hash: receipt.receipt.transactionHash,\n      }).then((x) => x.hash);\n    }\n  }\n\n  throw new FailedToFindTransactionError(hash);\n};\n"]}