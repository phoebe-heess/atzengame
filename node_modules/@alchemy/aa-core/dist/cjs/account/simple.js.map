{"version":3,"file":"simple.js","sourceRoot":"","sources":["../../../src/account/simple.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Address } from \"abitype\";\nimport {\n  concatHex,\n  encodeFunctionData,\n  isHex,\n  type Chain,\n  type FallbackTransport,\n  type Hex,\n  type Transport,\n} from \"viem\";\nimport { SimpleAccountAbi_v6 } from \"../abis/SimpleAccountAbi_v6.js\";\nimport { SimpleAccountAbi_v7 } from \"../abis/SimpleAccountAbi_v7.js\";\nimport { SimpleAccountFactoryAbi } from \"../abis/SimpleAccountFactoryAbi.js\";\nimport { createBundlerClient } from \"../client/bundlerClient.js\";\nimport {\n  defaultEntryPointVersion,\n  getEntryPoint,\n} from \"../entrypoint/index.js\";\nimport type {\n  DefaultEntryPointVersion,\n  EntryPointParameter,\n  EntryPointVersion,\n} from \"../entrypoint/types.js\";\nimport { AccountRequiresOwnerError } from \"../errors/account.js\";\nimport type { SmartAccountSigner } from \"../signer/types.js\";\nimport type { BatchUserOperationCallData } from \"../types.js\";\nimport { getDefaultSimpleAccountFactoryAddress } from \"../utils/defaults.js\";\nimport { BaseSmartContractAccount } from \"./base.js\";\nimport { SimpleSmartAccountParamsSchema } from \"./schema.js\";\nimport {\n  toSmartContractAccount,\n  type SmartContractAccountWithSigner,\n  type ToSmartContractAccountParams,\n} from \"./smartContractAccount.js\";\nimport type { SimpleSmartAccountParams } from \"./types.js\";\n\nclass SimpleSmartContractAccount<\n  TTransport extends Transport | FallbackTransport = Transport,\n  TSigner extends SmartAccountSigner = SmartAccountSigner\n> extends BaseSmartContractAccount<TTransport, TSigner> {\n  protected index: bigint;\n  protected entryPointVersion: EntryPointVersion;\n\n  constructor(params: SimpleSmartAccountParams<TTransport, TSigner>) {\n    SimpleSmartAccountParamsSchema().parse(params);\n\n    // This is a hack for now, we should kill the SimpleSmart Account when we kill Base Account\n    const client = createBundlerClient({\n      transport: params.transport as TTransport,\n      chain: params.chain,\n    });\n\n    // @ts-expect-error zod custom type not recognized as required params for signers\n    super({ ...params, rpcClient: client });\n    this.signer = params.signer as TSigner;\n    this.index = params.salt ?? 0n;\n    this.entryPointVersion =\n      params.entryPointVersion ?? defaultEntryPointVersion;\n  }\n\n  getDummySignature(): `0x${string}` {\n    return \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n  }\n\n  async encodeExecute(\n    target: Hex,\n    value: bigint,\n    data: Hex\n  ): Promise<`0x${string}`> {\n    return encodeFunctionData({\n      abi:\n        this.entryPointVersion === \"0.6.0\"\n          ? SimpleAccountAbi_v6\n          : SimpleAccountAbi_v7,\n      functionName: \"execute\",\n      args: [target, value, data],\n    });\n  }\n\n  override async encodeBatchExecute(\n    txs: BatchUserOperationCallData\n  ): Promise<`0x${string}`> {\n    const [targets, datas] = txs.reduce(\n      (accum, curr) => {\n        accum[0].push(curr.target);\n        accum[1].push(curr.data);\n\n        return accum;\n      },\n      [[], []] as [Address[], Hex[]]\n    );\n\n    return encodeFunctionData({\n      abi:\n        this.entryPointVersion === \"0.6.0\"\n          ? SimpleAccountAbi_v6\n          : SimpleAccountAbi_v7,\n      functionName: \"executeBatch\",\n      args: [targets, datas],\n    });\n  }\n\n  signMessage(msg: Uint8Array | string): Promise<`0x${string}`> {\n    return this.signer.signMessage(\n      typeof msg === \"string\" && !isHex(msg) ? msg : { raw: msg }\n    );\n  }\n\n  public async getAccountInitCode(): Promise<`0x${string}`> {\n    return concatHex([\n      this.factoryAddress,\n      encodeFunctionData({\n        abi: SimpleAccountFactoryAbi,\n        functionName: \"createAccount\",\n        args: [await this.signer.getAddress(), this.index],\n      }),\n    ]);\n  }\n}\n\nexport type SimpleSmartAccount<\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n  TEntryPointVersion extends EntryPointVersion = EntryPointVersion\n> = SmartContractAccountWithSigner<\n  \"SimpleAccount\",\n  TSigner,\n  TEntryPointVersion\n>;\n\nexport type CreateSimpleAccountParams<\n  TTransport extends Transport = Transport,\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n  TEntryPointVersion extends EntryPointVersion = DefaultEntryPointVersion\n> = Pick<\n  ToSmartContractAccountParams<\n    \"SimpleAccount\",\n    TTransport,\n    Chain,\n    TEntryPointVersion\n  >,\n  \"chain\" | \"transport\"\n> & {\n  signer: TSigner;\n  salt?: bigint;\n  accountAddress?: Address;\n  factoryAddress?: Address;\n  initCode?: Hex;\n} & EntryPointParameter<TEntryPointVersion, Chain>;\n\nexport async function createSimpleSmartAccount<\n  TTransport extends Transport = Transport,\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n  TEntryPointVersion extends EntryPointVersion = DefaultEntryPointVersion\n>(\n  config: CreateSimpleAccountParams<TTransport, TSigner, TEntryPointVersion>\n): Promise<SimpleSmartAccount<TSigner, TEntryPointVersion>>;\n\nexport async function createSimpleSmartAccount({\n  chain,\n  entryPoint = getEntryPoint(chain),\n  factoryAddress = getDefaultSimpleAccountFactoryAddress(\n    chain,\n    entryPoint.version\n  ),\n  ...params\n}: CreateSimpleAccountParams): Promise<SimpleSmartAccount> {\n  if (!params.signer) throw new AccountRequiresOwnerError(\"SimpleAccount\");\n  const simpleAccount = new SimpleSmartContractAccount(\n    SimpleSmartAccountParamsSchema().parse({\n      chain,\n      entryPointAddress: entryPoint.address,\n      factoryAddress,\n      ...params,\n    })\n  );\n\n  const parsedParams = SimpleSmartAccountParamsSchema().parse({\n    chain,\n    entryPointAddress: entryPoint.address,\n    entryPointVersion: entryPoint.version,\n    factoryAddress,\n    ...params,\n  });\n\n  const base = await toSmartContractAccount({\n    source: \"SimpleAccount\",\n    transport: params.transport,\n    chain,\n    encodeBatchExecute: simpleAccount.encodeBatchExecute.bind(simpleAccount),\n    encodeExecute: (tx) =>\n      simpleAccount.encodeExecute.bind(simpleAccount)(\n        tx.target,\n        tx.value ?? 0n,\n        tx.data\n      ),\n    entryPoint,\n    getAccountInitCode: async () => {\n      if (parsedParams.initCode) return parsedParams.initCode as Hex;\n      return simpleAccount.getAccountInitCode();\n    },\n    getDummySignature: simpleAccount.getDummySignature.bind(simpleAccount),\n    signMessage: ({ message }) =>\n      simpleAccount.signMessage(\n        typeof message === \"string\" ? message : message.raw\n      ),\n    // @ts-expect-error these types still represent the same thing, but they are just a little off in there definitions\n    signTypedData: simpleAccount.signTypedData.bind(simpleAccount),\n    accountAddress: parsedParams.accountAddress,\n  });\n\n  return {\n    ...base,\n    getSigner: () => simpleAccount.getSigner(),\n  };\n}\n"]}