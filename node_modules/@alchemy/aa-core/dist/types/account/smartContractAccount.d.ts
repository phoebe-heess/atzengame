import { type Address, type Chain, type CustomSource, type Hex, type LocalAccount, type PublicClient, type SignableMessage, type Transport, type TypedData, type TypedDataDefinition } from "viem";
import type { EntryPointDef, EntryPointRegistryBase, EntryPointVersion } from "../entrypoint/types.js";
import type { SmartAccountSigner } from "../signer/types.js";
import type { NullAddress } from "../types.js";
import type { IsUndefined } from "../utils/types.js";
export type AccountOp = {
    target: Address;
    value?: bigint;
    data: Hex | "0x";
};
export type GetEntryPointFromAccount<TAccount extends SmartContractAccount | undefined, TAccountOverride extends SmartContractAccount = SmartContractAccount> = GetAccountParameter<TAccount, TAccountOverride> extends SmartContractAccount<string, infer TEntryPointVersion> ? TEntryPointVersion : EntryPointVersion;
export type GetAccountParameter<TAccount extends SmartContractAccount | undefined = SmartContractAccount | undefined, TAccountOverride extends SmartContractAccount = SmartContractAccount> = IsUndefined<TAccount> extends true ? {
    account: TAccountOverride;
} : {
    account?: TAccountOverride;
};
export type UpgradeToAndCallParams = {
    upgradeToAddress: Address;
    upgradeToInitData: Hex;
};
export type SmartContractAccountWithSigner<Name extends string = string, TSigner extends SmartAccountSigner = SmartAccountSigner, TEntryPointVersion extends EntryPointVersion = EntryPointVersion> = SmartContractAccount<Name, TEntryPointVersion> & {
    getSigner: () => TSigner;
};
export declare const isSmartAccountWithSigner: (account: SmartContractAccount) => account is SmartContractAccountWithSigner<string, SmartAccountSigner<any>, keyof EntryPointRegistryBase<unknown>>;
export type SmartContractAccount<Name extends string = string, TEntryPointVersion extends EntryPointVersion = EntryPointVersion> = LocalAccount<Name> & {
    source: Name;
    getDummySignature: () => Hex | Promise<Hex>;
    encodeExecute: (tx: AccountOp) => Promise<Hex>;
    encodeBatchExecute: (txs: AccountOp[]) => Promise<Hex>;
    signUserOperationHash: (uoHash: Hex) => Promise<Hex>;
    signMessageWith6492: (params: {
        message: SignableMessage;
    }) => Promise<Hex>;
    signTypedDataWith6492: <const typedData extends TypedData | Record<string, unknown>, primaryType extends keyof typedData | "EIP712Domain" = keyof typedData>(typedDataDefinition: TypedDataDefinition<typedData, primaryType>) => Promise<Hex>;
    encodeUpgradeToAndCall: (params: UpgradeToAndCallParams) => Promise<Hex>;
    getNonce(nonceKey?: bigint): Promise<bigint>;
    getInitCode: () => Promise<Hex>;
    isAccountDeployed: () => Promise<boolean>;
    getFactoryAddress: () => Promise<Address>;
    getFactoryData: () => Promise<Hex>;
    getEntryPoint: () => EntryPointDef<TEntryPointVersion>;
    getImplementationAddress: () => Promise<NullAddress | Address>;
};
export interface AccountEntryPointRegistry<Name extends string = string> extends EntryPointRegistryBase<SmartContractAccount<Name, EntryPointVersion>> {
    "0.6.0": SmartContractAccount<Name, "0.6.0">;
    "0.7.0": SmartContractAccount<Name, "0.7.0">;
}
export type ToSmartContractAccountParams<Name extends string = string, TTransport extends Transport = Transport, TChain extends Chain = Chain, TEntryPointVersion extends EntryPointVersion = EntryPointVersion> = {
    source: Name;
    transport: TTransport;
    chain: TChain;
    entryPoint: EntryPointDef<TEntryPointVersion, TChain>;
    accountAddress?: Address;
    getAccountInitCode: () => Promise<Hex>;
    getDummySignature: () => Hex | Promise<Hex>;
    encodeExecute: (tx: AccountOp) => Promise<Hex>;
    encodeBatchExecute?: (txs: AccountOp[]) => Promise<Hex>;
    signUserOperationHash?: (uoHash: Hex) => Promise<Hex>;
    encodeUpgradeToAndCall?: (params: UpgradeToAndCallParams) => Promise<Hex>;
} & Omit<CustomSource, "signTransaction" | "address">;
export declare const parseFactoryAddressFromAccountInitCode: (initCode: Hex) => [Address, Hex];
export declare const getAccountAddress: ({ client, entryPoint, accountAddress, getAccountInitCode, }: {
    client: PublicClient;
    entryPoint: EntryPointDef;
    accountAddress?: `0x${string}` | undefined;
    getAccountInitCode: () => Promise<Hex>;
}) => Promise<`0x${string}`>;
export declare function toSmartContractAccount<Name extends string = string, TTransport extends Transport = Transport, TChain extends Chain = Chain, TEntryPointVersion extends EntryPointVersion = EntryPointVersion>({ transport, chain, entryPoint, source, accountAddress, getAccountInitCode, signMessage, signTypedData, encodeBatchExecute, encodeExecute, getDummySignature, signUserOperationHash, encodeUpgradeToAndCall, }: ToSmartContractAccountParams<Name, TTransport, TChain, TEntryPointVersion>): Promise<SmartContractAccount<Name, TEntryPointVersion>>;
//# sourceMappingURL=smartContractAccount.d.ts.map