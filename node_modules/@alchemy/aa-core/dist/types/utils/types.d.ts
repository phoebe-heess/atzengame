/**
 * @description Constructs a type by excluding `undefined` from `T`.
 *
 * @example
 * NoUndefined<string | undefined>
 * => string
 */
export type NoUndefined<T> = T extends undefined ? never : T;
/**
 * @description Checks if {@link T} is `undefined`
 * @param T - Type to check
 * @example
 * type Result = IsUndefined<undefined>
 * //   ^? type Result = true
 */
export type IsUndefined<T> = [undefined] extends [T] ? true : false;
export type RequiredBy<TType, TKeys extends keyof TType> = Required<Pick<TType, TKeys>> & Omit<TType, TKeys>;
/**
 * @description Combines members of an intersection into a readable type.
 *
 * @see {@link https://twitter.com/mattpocockuk/status/1622730173446557697?s=20&t=NdpAcmEFXY01xkqU3KO0Mg}
 * @example
 * Prettify<{ a: string } & { b: string } & { c: number, d: bigint }>
 * => { a: string, b: string, c: number, d: bigint }
 */
export type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
export type WithRequired<T, K extends keyof T> = Required<Pick<T, K>>;
export type WithOptional<T, K extends keyof T> = Pick<Partial<T>, K>;
export type EQ<A, B> = [A] extends [B] ? [B] extends [A] ? true : false : false;
export type EqualsOneOfTheComponents<T, Union> = Union extends infer Component ? EQ<T, Component> : never;
export type IsMemberOrSubtypeOfAComponent<T, Union, ConjunctionOfExplicitComponentChecks extends boolean> = [T] extends [Union] ? true extends ConjunctionOfExplicitComponentChecks ? true : false : false;
export type IsOneOf<T, Union> = IsMemberOrSubtypeOfAComponent<T, Union, EqualsOneOfTheComponents<T, Union>>;
export type OneOf<T1, T2> = IsOneOf<T1, T2> extends true ? T1 : never;
export type RecordableKeys<T> = {
    [K in keyof T]: T[K] extends string | number | symbol ? K : never;
}[keyof T];
//# sourceMappingURL=types.d.ts.map