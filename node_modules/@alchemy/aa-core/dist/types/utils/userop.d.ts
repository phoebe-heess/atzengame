import { type Hex } from "viem";
import type { EntryPointVersion } from "../entrypoint/types";
import type { BigNumberish, Multiplier, UserOperationFeeOptionsField, UserOperationOverrides, UserOperationRequest, UserOperationStruct } from "../types";
/**
 * Utility method for asserting a {@link UserOperationStruct} has valid fields for the given entry point version
 *
 * @param request a {@link UserOperationStruct} to validate
 * @returns a type guard that asserts the {@link UserOperationRequest} is valid
 */
export declare function isValidRequest<TEntryPointVersion extends EntryPointVersion = EntryPointVersion>(request: UserOperationStruct<TEntryPointVersion>): request is UserOperationRequest<TEntryPointVersion>;
/**
 * Utility method for asserting a {@link UserOperationRequest} has valid fields for the paymaster data
 *
 * @param request a {@link UserOperationRequest} to validate
 * @returns a type guard that asserts the {@link UserOperationRequest} is a {@link UserOperationRequest}
 */
export declare function isValidPaymasterAndData<TEntryPointVersion extends EntryPointVersion = EntryPointVersion>(request: UserOperationStruct<TEntryPointVersion>): boolean;
/**
 * Utility method for asserting a {@link UserOperationStruct} has valid fields for the paymaster data
 *
 * @param request a {@link UserOperationRequest} to validate
 * @returns a type guard that asserts the {@link UserOperationStruct} is a {@link UserOperationRequest}
 */
export declare function isValidFactoryAndData<TEntryPointVersion extends EntryPointVersion = EntryPointVersion>(request: UserOperationStruct<TEntryPointVersion>): boolean;
/**
 * Utility method for applying a {@link UserOperationOverrides} field value
 * over the current value set for the field
 *
 * @param value the current value of the field
 * @param override the override value to apply
 * @returns the new value of the field after applying the override
 */
export declare function applyUserOpOverride<TValue extends BigNumberish | undefined>(value: TValue, override?: BigNumberish | Multiplier): TValue | BigNumberish;
/**
 * Utility method for applying a {@link UserOperationFeeOptionsField} value
 * over the current value set for the field
 *
 * @param value the current value of the field
 * @param feeOption the fee option field value to apply
 * @returns the new value of the field after applying the fee option
 */
export declare function applyUserOpFeeOption<TValue extends BigNumberish | undefined>(value: TValue, feeOption?: UserOperationFeeOptionsField): TValue | BigNumberish;
/**
 * Utility method for applying a {@link UserOperationOverrides} field value and
 * a {@link UserOperationFeeOptionsField} value over the current value set for the field,
 * with the override taking precedence over the fee option
 *
 * @param value the current value of the field
 * @param [override] the override value to apply
 * @param [feeOption] the fee option field value to apply
 * @returns the new value of the field after applying the override or fee option
 */
export declare function applyUserOpOverrideOrFeeOption<TValue extends BigNumberish | undefined>(value: TValue, override?: BigNumberish | Multiplier, feeOption?: UserOperationFeeOptionsField): TValue | BigNumberish;
/**
 * Utility method for checking whether the middleware pipeline should
 * bypass the paymaster middleware for the user operation with the given overrides,
 * either because the UserOp is paying for its own gas, or passing a specific paymaster
 *
 * @template EntryPointVersion TEntryPointVersion
 * @param overrides the user operation overrides to check
 * @returns whether the paymaster middleware should be bypassed
 */
export declare const bypassPaymasterAndData: <TEntryPointVersion extends keyof import("../entrypoint/types").EntryPointRegistryBase<unknown> = keyof import("../entrypoint/types").EntryPointRegistryBase<unknown>>(overrides: Partial<{
    callGasLimit: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["callGasLimit"];
    maxFeePerGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["maxFeePerGas"];
    maxPriorityFeePerGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["maxPriorityFeePerGas"];
    preVerificationGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["preVerificationGas"];
    verificationGasLimit: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["verificationGasLimit"];
    nonceKey: bigint;
    stateOverride: import("viem").StateOverride;
} & import("../types").UserOperationPaymasterOverrides<TEntryPointVersion>> | undefined) => boolean;
/**
 * An alternative to `bypassPaymasterAndData` which only returns true if the data parameter
 * is "0x," this is useful for cases when middleware should be bypassed ONLY IF the UserOp will
 * pay for its own gas
 *
 * @template EntryPointVersion TEntryPointVersion
 * @param overrides the user operation overrides to check
 * @returns whether the paymaster middleware should be bypassed
 */
export declare const bypassPaymasterAndDataEmptyHex: <TEntryPointVersion extends keyof import("../entrypoint/types").EntryPointRegistryBase<unknown> = keyof import("../entrypoint/types").EntryPointRegistryBase<unknown>>(overrides: Partial<{
    callGasLimit: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["callGasLimit"];
    maxFeePerGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["maxFeePerGas"];
    maxPriorityFeePerGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["maxPriorityFeePerGas"];
    preVerificationGas: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["preVerificationGas"];
    verificationGasLimit: {
        multiplier: number;
    } | UserOperationStruct<TEntryPointVersion>["verificationGasLimit"];
    nonceKey: bigint;
    stateOverride: import("viem").StateOverride;
} & import("../types").UserOperationPaymasterOverrides<TEntryPointVersion>> | undefined) => boolean;
/**
 * Utility method for parsing the paymaster address and paymasterData from the paymasterAndData hex string
 *
 * @param paymasterAndData the paymaster and data hex string to parse.
 *                         The hex string refers to the paymasterAndData field of entrypoint v0.6 user operation request
 * @returns the parsed paymaster and paymasterData fields of entrypoint v0.7 user operation request paymaster and paymasterData field
 */
export declare const parsePaymasterAndData: (paymasterAndData: Hex) => Pick<UserOperationRequest<"0.7.0">, "paymaster" | "paymasterData">;
/**
 * Utility method for converting the object containing the paymaster address and paymaster data
 * to the paymaster and data concatenated hex string
 *
 * @param paymasterAndData the object containing the picked paymaster and paymasterData fields of
 *                         entrypoint v0.7 user operation request
 * @param paymasterAndData.paymaster the paymaster address
 * @param paymasterAndData.paymasterData the paymaster data
 * @returns the paymasterAndData hex value of entrypoint v0.6 user operation request paymasterAndData field
 */
export declare const concatPaymasterAndData: ({ paymaster, paymasterData, }: Pick<UserOperationRequest<"0.7.0">, "paymaster" | "paymasterData">) => Hex;
//# sourceMappingURL=userop.d.ts.map