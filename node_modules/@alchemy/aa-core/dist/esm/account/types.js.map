{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/account/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { Address } from \"abitype\";\nimport type { Hash, Hex, HttpTransport, Transport } from \"viem\";\nimport type { SignTypedDataParameters } from \"viem/accounts\";\nimport type { z } from \"zod\";\nimport type { BundlerClient } from \"../client/bundlerClient\";\nimport type { SmartAccountSigner } from \"../signer/types\";\nimport type { BatchUserOperationCallData } from \"../types\";\nimport type {\n  SimpleSmartAccountParamsSchema,\n  createBaseSmartAccountParamsSchema,\n} from \"./schema\";\n\n/** @deprecated */\nexport type SignTypedDataParams = Omit<SignTypedDataParameters, \"privateKey\">;\n\n/**\n * @deprecated don't use base smart account anymore, migrate to using toSmartContractAccount instead\n */\nexport type BaseSmartAccountParams<\n  TTransport extends Transport = Transport,\n  TSigner extends SmartAccountSigner = SmartAccountSigner\n> = z.input<\n  ReturnType<typeof createBaseSmartAccountParamsSchema<TTransport, TSigner>>\n>;\n\nexport type SimpleSmartAccountParams<\n  TTransport extends Transport = Transport,\n  TSigner extends SmartAccountSigner = SmartAccountSigner\n> = z.input<\n  ReturnType<typeof SimpleSmartAccountParamsSchema<TTransport, TSigner>>\n>;\n\n/**\n * @deprecated use `toSmartContractAccount` instead for creating instances of smart accounts\n */\nexport interface ISmartContractAccount<\n  TTransport extends Transport = Transport,\n  TSigner extends SmartAccountSigner = SmartAccountSigner\n> {\n  /**\n   * The RPC provider the account uses to make RPC calls\n   */\n  readonly rpcProvider:\n    | BundlerClient<TTransport>\n    | BundlerClient<HttpTransport>;\n\n  /**\n   * @returns the init code for the account\n   */\n  getInitCode(): Promise<Hex>;\n\n  /**\n   * This is useful for estimating gas costs. It should return a signature that doesn't cause the account to revert\n   * when validation is run during estimation.\n   *\n   * @returns a dummy signature that doesn't cause the account to revert during estimation\n   */\n  getDummySignature(): Hex | Promise<Hex>;\n\n  /**\n   * Encodes a call to the account's execute function.\n   *\n   * @param target - the address receiving the call data\n   * @param value - optionally the amount of native token to send\n   * @param data - the call data or \"0x\" if empty\n   */\n  encodeExecute(target: string, value: bigint, data: string): Promise<Hex>;\n\n  /**\n   * Encodes a batch of transactions to the account's batch execute function.\n   * NOTE: not all accounts support batching.\n   *\n   * @param txs - An Array of objects containing the target, value, and data for each transaction\n   * @returns the encoded callData for a UserOperation\n   */\n  encodeBatchExecute(txs: BatchUserOperationCallData): Promise<Hex>;\n\n  /**\n   * @returns the nonce of the account\n   */\n  getNonce(): Promise<bigint>;\n\n  /**\n   * If your account handles 1271 signatures of personal_sign differently\n   * than it does UserOperations, you can implement two different approaches to signing\n   *\n   * @param uoHash -- The hash of the UserOperation to sign\n   * @returns the signature of the UserOperation\n   */\n  signUserOperationHash(uoHash: Hash): Promise<Hash>;\n\n  /**\n   * Returns a signed and prefixed message.\n   *\n   * @param msg - the message to sign\n   * @returns the signature of the message\n   */\n  signMessage(msg: string | Uint8Array | Hex): Promise<Hex>;\n\n  /**\n   * Signs a typed data object as per ERC-712\n   *\n   * @param params - {@link SignTypedDataParams}\n   * @returns the signed hash for the message passed\n   */\n  signTypedData(params: SignTypedDataParams): Promise<Hash>;\n\n  /**\n   * If the account is not deployed, it will sign the message and then wrap it in 6492 format\n   *\n   * @param msg - the message to sign\n   * @returns ths signature wrapped in 6492 format\n   */\n  signMessageWith6492(msg: string | Uint8Array | Hex): Promise<Hex>;\n\n  /**\n   * If the account is not deployed, it will sign the typed data blob and then wrap it in 6492 format\n   *\n   * @param params - {@link SignTypedDataParams}\n   * @returns the signed hash for the params passed in wrapped in 6492 format\n   */\n  signTypedDataWith6492(params: SignTypedDataParams): Promise<Hash>;\n\n  /**\n   * @returns the address of the account\n   */\n  getAddress(): Promise<Address>;\n\n  /**\n   * @returns the current account signer instance that the smart account client\n   * operations are being signed with.\n   *\n   * The signer is expected to be the owner or one of the owners of the account\n   * for the signatures to be valid for the acting account.\n   */\n  getSigner(): TSigner;\n\n  /**\n   * The factory address of the smart account created by the factory\n   *\n   * @returns the address of the factory contract for the smart account\n   */\n  getFactoryAddress(): Address;\n\n  /**\n   * The entrypoint address is the address ERC 4337 entrypoint singleton contract\n   * that this smart account and the connected bundler client use\n   *\n   * @returns the address of the entry point contract for the smart account\n   */\n  getEntryPointAddress(): Address;\n\n  /**\n   * Allows you to add additional functionality and utility methods to this account\n   * via a decorator pattern.\n   *\n   * NOTE: this method does not allow you to override existing methods on the account.\n   *\n   * @example\n   * ```ts\n   * const account = new BaseSmartCobntractAccount(...).extend((account) => ({\n   *  readAccountState: async (...args) => {\n   *    return this.rpcProvider.readContract({\n   *        address: await this.getAddress(),\n   *        abi: ThisContractsAbi\n   *        args: args\n   *    });\n   *  }\n   * }));\n   *\n   * account.debugSendUserOperation(...);\n   * ```\n   *\n   * @param extendFn -- this function gives you access to the created account instance and returns an object\n   * with the extension methods\n   * @returns -- the account with the extension methods added\n   */\n  extend: <R>(extendFn: (self: this) => R) => this & R;\n\n  encodeUpgradeToAndCall: (\n    upgradeToImplAddress: Address,\n    upgradeToInitData: Hex\n  ) => Promise<Hex>;\n}\n"]}