{"version":3,"file":"smartContractAccount.js","sourceRoot":"","sources":["../../../src/account/smartContractAccount.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  getContract,\n  hexToBytes,\n  trim,\n  type Address,\n  type Chain,\n  type CustomSource,\n  type Hex,\n  type LocalAccount,\n  type PublicClient,\n  type SignableMessage,\n  type Transport,\n  type TypedData,\n  type TypedDataDefinition,\n} from \"viem\";\nimport { toAccount } from \"viem/accounts\";\nimport { createBundlerClient } from \"../client/bundlerClient.js\";\nimport type {\n  EntryPointDef,\n  EntryPointRegistryBase,\n  EntryPointVersion,\n} from \"../entrypoint/types.js\";\nimport {\n  BatchExecutionNotSupportedError,\n  FailedToGetStorageSlotError,\n  GetCounterFactualAddressError,\n  SignTransactionNotSupportedError,\n  UpgradesNotSupportedError,\n} from \"../errors/account.js\";\nimport { InvalidRpcUrlError } from \"../errors/client.js\";\nimport { InvalidEntryPointError } from \"../errors/entrypoint.js\";\nimport { Logger } from \"../logger.js\";\nimport type { SmartAccountSigner } from \"../signer/types.js\";\nimport { wrapSignatureWith6492 } from \"../signer/utils.js\";\nimport type { NullAddress } from \"../types.js\";\nimport type { IsUndefined } from \"../utils/types.js\";\nimport { DeploymentState } from \"./base.js\";\n\nexport type AccountOp = {\n  target: Address;\n  value?: bigint;\n  data: Hex | \"0x\";\n};\n\nexport type GetEntryPointFromAccount<\n  TAccount extends SmartContractAccount | undefined,\n  TAccountOverride extends SmartContractAccount = SmartContractAccount\n> = GetAccountParameter<\n  TAccount,\n  TAccountOverride\n> extends SmartContractAccount<string, infer TEntryPointVersion>\n  ? TEntryPointVersion\n  : EntryPointVersion;\n\nexport type GetAccountParameter<\n  TAccount extends SmartContractAccount | undefined =\n    | SmartContractAccount\n    | undefined,\n  TAccountOverride extends SmartContractAccount = SmartContractAccount\n> = IsUndefined<TAccount> extends true\n  ? { account: TAccountOverride }\n  : { account?: TAccountOverride };\n\nexport type UpgradeToAndCallParams = {\n  upgradeToAddress: Address;\n  upgradeToInitData: Hex;\n};\n\nexport type SmartContractAccountWithSigner<\n  Name extends string = string,\n  TSigner extends SmartAccountSigner = SmartAccountSigner,\n  TEntryPointVersion extends EntryPointVersion = EntryPointVersion\n> = SmartContractAccount<Name, TEntryPointVersion> & {\n  getSigner: () => TSigner;\n};\n\nexport const isSmartAccountWithSigner = (\n  account: SmartContractAccount\n): account is SmartContractAccountWithSigner => {\n  return \"getSigner\" in account;\n};\n\n// [!region SmartContractAccount]\nexport type SmartContractAccount<\n  Name extends string = string,\n  TEntryPointVersion extends EntryPointVersion = EntryPointVersion\n> = LocalAccount<Name> & {\n  source: Name;\n  getDummySignature: () => Hex | Promise<Hex>;\n  encodeExecute: (tx: AccountOp) => Promise<Hex>;\n  encodeBatchExecute: (txs: AccountOp[]) => Promise<Hex>;\n  signUserOperationHash: (uoHash: Hex) => Promise<Hex>;\n  signMessageWith6492: (params: { message: SignableMessage }) => Promise<Hex>;\n  signTypedDataWith6492: <\n    const typedData extends TypedData | Record<string, unknown>,\n    primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData\n  >(\n    typedDataDefinition: TypedDataDefinition<typedData, primaryType>\n  ) => Promise<Hex>;\n  encodeUpgradeToAndCall: (params: UpgradeToAndCallParams) => Promise<Hex>;\n  getNonce(nonceKey?: bigint): Promise<bigint>;\n  getInitCode: () => Promise<Hex>;\n  isAccountDeployed: () => Promise<boolean>;\n  getFactoryAddress: () => Promise<Address>;\n  getFactoryData: () => Promise<Hex>;\n  getEntryPoint: () => EntryPointDef<TEntryPointVersion>;\n  getImplementationAddress: () => Promise<NullAddress | Address>;\n};\n// [!endregion SmartContractAccount]\n\nexport interface AccountEntryPointRegistry<Name extends string = string>\n  extends EntryPointRegistryBase<\n    SmartContractAccount<Name, EntryPointVersion>\n  > {\n  \"0.6.0\": SmartContractAccount<Name, \"0.6.0\">;\n  \"0.7.0\": SmartContractAccount<Name, \"0.7.0\">;\n}\n\n// [!region ToSmartContractAccountParams]\nexport type ToSmartContractAccountParams<\n  Name extends string = string,\n  TTransport extends Transport = Transport,\n  TChain extends Chain = Chain,\n  TEntryPointVersion extends EntryPointVersion = EntryPointVersion\n> = {\n  source: Name;\n  transport: TTransport;\n  chain: TChain;\n  entryPoint: EntryPointDef<TEntryPointVersion, TChain>;\n  accountAddress?: Address;\n  getAccountInitCode: () => Promise<Hex>;\n  getDummySignature: () => Hex | Promise<Hex>;\n  encodeExecute: (tx: AccountOp) => Promise<Hex>;\n  encodeBatchExecute?: (txs: AccountOp[]) => Promise<Hex>;\n  // if not provided, will default to just using signMessage over the Hex\n  signUserOperationHash?: (uoHash: Hex) => Promise<Hex>;\n  encodeUpgradeToAndCall?: (params: UpgradeToAndCallParams) => Promise<Hex>;\n} & Omit<CustomSource, \"signTransaction\" | \"address\">;\n// [!endregion ToSmartContractAccountParams]\n\nexport const parseFactoryAddressFromAccountInitCode = (\n  initCode: Hex\n): [Address, Hex] => {\n  const factoryAddress: Address = `0x${initCode.substring(2, 42)}`;\n  const factoryCalldata: Hex = `0x${initCode.substring(42)}`;\n  return [factoryAddress, factoryCalldata];\n};\n\nexport const getAccountAddress = async ({\n  client,\n  entryPoint,\n  accountAddress,\n  getAccountInitCode,\n}: {\n  client: PublicClient;\n  entryPoint: EntryPointDef;\n  accountAddress?: Address;\n  getAccountInitCode: () => Promise<Hex>;\n}) => {\n  if (accountAddress) return accountAddress;\n\n  const entryPointContract = getContract({\n    address: entryPoint.address,\n    abi: entryPoint.abi,\n    client,\n  });\n\n  const initCode = await getAccountInitCode();\n  Logger.verbose(\"[BaseSmartContractAccount](getAddress) initCode: \", initCode);\n\n  try {\n    await entryPointContract.simulate.getSenderAddress([initCode]);\n  } catch (err: any) {\n    Logger.verbose(\n      \"[BaseSmartContractAccount](getAddress) getSenderAddress err: \",\n      err\n    );\n    if (err.cause?.data?.errorName === \"SenderAddressResult\") {\n      Logger.verbose(\n        \"[BaseSmartContractAccount](getAddress) entryPoint.getSenderAddress result:\",\n        err.cause.data.args[0]\n      );\n\n      return err.cause.data.args[0] as Address;\n    }\n\n    if (err.details === \"Invalid URL\") {\n      throw new InvalidRpcUrlError();\n    }\n  }\n\n  throw new GetCounterFactualAddressError();\n};\n\n// [!region toSmartContractAccount]\nexport async function toSmartContractAccount<\n  Name extends string = string,\n  TTransport extends Transport = Transport,\n  TChain extends Chain = Chain,\n  TEntryPointVersion extends EntryPointVersion = EntryPointVersion\n>({\n  transport,\n  chain,\n  entryPoint,\n  source,\n  accountAddress,\n  getAccountInitCode,\n  signMessage,\n  signTypedData,\n  encodeBatchExecute,\n  encodeExecute,\n  getDummySignature,\n  signUserOperationHash,\n  encodeUpgradeToAndCall,\n}: ToSmartContractAccountParams<\n  Name,\n  TTransport,\n  TChain,\n  TEntryPointVersion\n>): Promise<SmartContractAccount<Name, TEntryPointVersion>>;\n// [!endregion toSmartContractAccount]\n\nexport async function toSmartContractAccount({\n  transport,\n  chain,\n  entryPoint,\n  source,\n  accountAddress,\n  getAccountInitCode,\n  signMessage,\n  signTypedData,\n  encodeBatchExecute,\n  encodeExecute,\n  getDummySignature,\n  signUserOperationHash,\n  encodeUpgradeToAndCall,\n}: ToSmartContractAccountParams): Promise<SmartContractAccount> {\n  const client = createBundlerClient({\n    // we set the retry count to 0 so that viem doesn't retry during\n    // getting the address. That call always reverts and without this\n    // viem will retry 3 times, making this call very slow\n    transport: (opts) => transport({ ...opts, chain, retryCount: 0 }),\n    chain,\n  });\n\n  const entryPointContract = getContract({\n    address: entryPoint.address,\n    abi: entryPoint.abi,\n    client,\n  });\n\n  const accountAddress_ = await getAccountAddress({\n    client,\n    entryPoint: entryPoint,\n    accountAddress,\n    getAccountInitCode,\n  });\n\n  let deploymentState = DeploymentState.UNDEFINED;\n\n  const getInitCode = async () => {\n    if (deploymentState === DeploymentState.DEPLOYED) {\n      return \"0x\";\n    }\n\n    const contractCode = await client.getBytecode({\n      address: accountAddress_,\n    });\n\n    if ((contractCode?.length ?? 0) > 2) {\n      deploymentState = DeploymentState.DEPLOYED;\n      return \"0x\";\n    } else {\n      deploymentState = DeploymentState.NOT_DEPLOYED;\n    }\n\n    return getAccountInitCode();\n  };\n\n  const signUserOperationHash_ =\n    signUserOperationHash ??\n    (async (uoHash: Hex) => {\n      return signMessage({ message: { raw: hexToBytes(uoHash) } });\n    });\n\n  const getFactoryAddress = async (): Promise<Address> =>\n    parseFactoryAddressFromAccountInitCode(await getAccountInitCode())[0];\n\n  const getFactoryData = async (): Promise<Hex> =>\n    parseFactoryAddressFromAccountInitCode(await getAccountInitCode())[1];\n\n  const encodeUpgradeToAndCall_ =\n    encodeUpgradeToAndCall ??\n    (() => {\n      throw new UpgradesNotSupportedError(source);\n    });\n\n  const isAccountDeployed = async () => {\n    const initCode = await getInitCode();\n    return initCode === \"0x\";\n  };\n\n  const getNonce = async (nonceKey = 0n): Promise<bigint> => {\n    if (!(await isAccountDeployed())) {\n      return 0n;\n    }\n\n    return entryPointContract.read.getNonce([\n      accountAddress_,\n      nonceKey,\n    ]) as Promise<bigint>;\n  };\n\n  const account = toAccount({\n    address: accountAddress_,\n    signMessage,\n    signTypedData,\n    signTransaction: () => {\n      throw new SignTransactionNotSupportedError();\n    },\n  });\n\n  const create6492Signature = async (isDeployed: boolean, signature: Hex) => {\n    if (isDeployed) {\n      return signature;\n    }\n\n    const [factoryAddress, factoryCalldata] =\n      parseFactoryAddressFromAccountInitCode(await getAccountInitCode());\n\n    return wrapSignatureWith6492({\n      factoryAddress,\n      factoryCalldata,\n      signature,\n    });\n  };\n\n  const signMessageWith6492 = async (message: { message: SignableMessage }) => {\n    const [isDeployed, signature] = await Promise.all([\n      isAccountDeployed(),\n      account.signMessage(message),\n    ]);\n\n    return create6492Signature(isDeployed, signature);\n  };\n\n  const signTypedDataWith6492 = async <\n    const typedData extends TypedData | Record<string, unknown>,\n    primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData\n  >(\n    typedDataDefinition: TypedDataDefinition<typedData, primaryType>\n  ): Promise<Hex> => {\n    const [isDeployed, signature] = await Promise.all([\n      isAccountDeployed(),\n      account.signTypedData(typedDataDefinition),\n    ]);\n\n    return create6492Signature(isDeployed, signature);\n  };\n\n  const getImplementationAddress = async (): Promise<NullAddress | Address> => {\n    const storage = await client.getStorageAt({\n      address: account.address,\n      // This is the default slot for the implementation address for Proxies\n      slot: \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n    });\n\n    if (storage == null) {\n      throw new FailedToGetStorageSlotError(\n        \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\",\n        \"Proxy Implementation Address\"\n      );\n    }\n\n    return trim(storage);\n  };\n\n  if (entryPoint.version !== \"0.6.0\" && entryPoint.version !== \"0.7.0\") {\n    throw new InvalidEntryPointError(chain, entryPoint.version);\n  }\n\n  return {\n    ...account,\n    source,\n    // TODO: I think this should probably be signUserOperation instead\n    // and allow for generating the UO hash based on the EP version\n    signUserOperationHash: signUserOperationHash_,\n    getFactoryAddress,\n    getFactoryData,\n    encodeBatchExecute:\n      encodeBatchExecute ??\n      (() => {\n        throw new BatchExecutionNotSupportedError(source);\n      }),\n    encodeExecute,\n    getDummySignature,\n    getInitCode,\n    encodeUpgradeToAndCall: encodeUpgradeToAndCall_,\n    getEntryPoint: () => entryPoint,\n    isAccountDeployed,\n    getNonce,\n    signMessageWith6492,\n    signTypedDataWith6492,\n    getImplementationAddress,\n  };\n}\n"]}