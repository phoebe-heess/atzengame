import type { Address } from "abitype";
import { type GetContractReturnType, type Hash, type Hex, type HttpTransport, type PublicClient, type Transport } from "viem";
import { EntryPointAbi_v6 as EntryPointAbi } from "../abis/EntryPointAbi_v6.js";
import { type BundlerClient } from "../client/bundlerClient.js";
import type { SmartAccountSigner } from "../signer/types.js";
import type { BatchUserOperationCallData, NullAddress } from "../types.js";
import type { BaseSmartAccountParams, ISmartContractAccount, SignTypedDataParams } from "./types.js";
export declare enum DeploymentState {
    UNDEFINED = "0x0",
    NOT_DEPLOYED = "0x1",
    DEPLOYED = "0x2"
}
export declare abstract class BaseSmartContractAccount<TTransport extends Transport = Transport, TSigner extends SmartAccountSigner = SmartAccountSigner> implements ISmartContractAccount<TTransport, TSigner> {
    protected factoryAddress: Address;
    protected deploymentState: DeploymentState;
    protected accountAddress?: Address;
    protected accountInitCode?: Hex;
    protected signer: TSigner;
    protected entryPoint: GetContractReturnType<typeof EntryPointAbi, PublicClient>;
    protected entryPointAddress: Address;
    readonly rpcProvider: BundlerClient<TTransport> | BundlerClient<HttpTransport>;
    constructor(params_: BaseSmartAccountParams<TTransport, TSigner>);
    abstract getDummySignature(): Hex | Promise<Hex>;
    abstract encodeExecute(target: string, value: bigint, data: string): Promise<Hash>;
    abstract signMessage(msg: string | Uint8Array): Promise<Hash>;
    protected abstract getAccountInitCode(): Promise<Hash>;
    signUserOperationHash(uoHash: Hash): Promise<Hash>;
    signTypedData(_params: SignTypedDataParams): Promise<`0x${string}`>;
    signMessageWith6492(msg: string | Uint8Array): Promise<`0x${string}`>;
    signTypedDataWith6492(params: SignTypedDataParams): Promise<`0x${string}`>;
    encodeBatchExecute(_txs: BatchUserOperationCallData): Promise<`0x${string}`>;
    encodeUpgradeToAndCall: (_upgradeToImplAddress: Address, _upgradeToInitData: Hex) => Promise<Hex>;
    getNonce(): Promise<bigint>;
    getInitCode(): Promise<Hex>;
    getAddress(): Promise<Address>;
    extend: <R>(fn: (self: this) => R) => this & R;
    getSigner(): TSigner;
    getFactoryAddress(): Address;
    getEntryPointAddress(): Address;
    isAccountDeployed(): Promise<boolean>;
    getDeploymentState(): Promise<DeploymentState>;
    protected parseFactoryAddressFromAccountInitCode(): Promise<[
        Address,
        Hex
    ]>;
    protected getImplementationAddress(): Promise<NullAddress | Address>;
    private _getAccountInitCode;
    private create6492Signature;
}
