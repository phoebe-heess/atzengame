{"version":3,"file":"buildUserOperationFromTx.js","sourceRoot":"","sources":["../../../../src/actions/smartAccount/buildUserOperationFromTx.ts"],"names":[],"mappings":"AAAA,OAAO,EAKN,MAAM,MAAM,CAAC;AAKd,OAAO,EAAE,wBAAwB,EAAE,MAAM,sCAAsC,CAAC;AAChF,OAAO,EAAE,oBAAoB,EAAE,MAAM,yBAAyB,CAAC;AAC/D,OAAO,EAAE,uBAAuB,EAAE,MAAM,wBAAwB,CAAC;AACjE,OAAO,EAAE,8BAA8B,EAAE,MAAM,6BAA6B,CAAC;AAK7E,OAAO,EAAE,kBAAkB,EAAE,MAAM,yBAAyB,CAAC;AA0C7D,MAAM,CAAC,KAAK,UAAU,wBAAwB,CAW5C,MAA2C,EAC3C,IAAiE,EACjE,SAAsD,EACtD,OAAkB;IAElB,MAAM,EAAE,OAAO,GAAG,MAAM,CAAC,OAAO,EAAE,GAAG,OAAO,EAAE,GAAG,IAAI,CAAC;IACtD,IAAI,CAAC,OAAO,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE,CAAC;QAC5C,MAAM,IAAI,oBAAoB,EAAE,CAAC;IACnC,CAAC;IAED,IAAI,CAAC,OAAO,CAAC,EAAE,EAAE,CAAC;QAChB,MAAM,IAAI,8BAA8B,EAAE,CAAC;IAC7C,CAAC;IAED,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,EAAE,CAAC;QACtC,MAAM,IAAI,uBAAuB,CAC/B,wBAAwB,EACxB,0BAA0B,EAC1B,MAAM,CACP,CAAC;IACJ,CAAC;IAED,MAAM,UAAU,GAAG;QACjB,GAAG,SAAS;QACZ,YAAY,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC,SAAS;QACrE,oBAAoB,EAAE,OAAO,CAAC,oBAAoB;YAChD,CAAC,CAAC,OAAO,CAAC,oBAAoB;YAC9B,CAAC,CAAC,SAAS;KACgC,CAAC;IAEhD,OAAO,kBAAkB,CAAC,MAAM,EAAE;QAChC,EAAE,EAAE;YACF,MAAM,EAAE,OAAO,CAAC,EAAE;YAClB,IAAI,EAAE,OAAO,CAAC,IAAI,IAAI,IAAI;YAC1B,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;SAC1C;QACD,OAAO,EAAE,OAA+B;QACxC,OAAO;QACP,SAAS,EAAE,UAAU;KACtB,CAAC,CAAC;AACL,CAAC","sourcesContent":["import {\n  type Chain,\n  type Client,\n  type SendTransactionParameters,\n  type Transport,\n} from \"viem\";\nimport type {\n  GetEntryPointFromAccount,\n  SmartContractAccount,\n} from \"../../account/smartContractAccount.js\";\nimport { isBaseSmartAccountClient } from \"../../client/isSmartAccountClient.js\";\nimport { AccountNotFoundError } from \"../../errors/account.js\";\nimport { IncompatibleClientError } from \"../../errors/client.js\";\nimport { TransactionMissingToParamError } from \"../../errors/transaction.js\";\nimport type {\n  UserOperationOverrides,\n  UserOperationStruct,\n} from \"../../types.js\";\nimport { buildUserOperation } from \"./buildUserOperation.js\";\nimport type { UserOperationContext } from \"./types.js\";\n\n/**\n * Performs [`buildUserOperationFromTx`](./buildUserOperationFromTx.md) in batch and builds into a single, yet to be signed `UserOperation` (UO) struct. The output user operation struct will be filled with all gas fields (and paymaster data if a paymaster is used) based on the transactions data (`to`, `data`, `value`, `maxFeePerGas`, `maxPriorityFeePerGas`) computed using the configured [`ClientMiddlewares`](/packages/aa-core/smart-account-client/middleware/index) on the `SmartAccountClient`\n * \n * @example\n * ```ts\nimport type { RpcTransactionRequest } from \"viem\";\nimport { smartAccountClient } from \"./smartAccountClient\";\n// [!code focus:99]\n// buildUserOperationFromTx converts a traditional Ethereum transaction and returns\n// the unsigned user operation struct after constructing the user operation struct\n// through the middleware pipeline\nconst tx: RpcTransactionRequest = {\n  from, // ignored\n  to,\n  data: encodeFunctionData({\n    abi: ContractABI.abi,\n    functionName: \"func\",\n    args: [arg1, arg2, ...],\n  }),\n};\nconst uoStruct = await smartAccountClient.buildUserOperationFromTx(tx);\n \n// signUserOperation signs the above unsigned user operation struct built\n// using the account connected to the smart account client\nconst request = await smartAccountClient.signUserOperation({ uoStruct });\n \n// You can use the BundlerAction `sendRawUserOperation` (packages/core/src/actions/bundler/sendRawUserOperation.ts)\n// to send the signed user operation request to the bundler, requesting the bundler to send the signed uo to the\n// EntryPoint contract pointed at by the entryPoint address parameter\nconst entryPointAddress = client.account.getEntryPoint().address;\nconst uoHash = await smartAccountClient.sendRawUserOperation({ request, entryPoint: entryPointAddress });\n```\n * \n * @param client the smart account client to use for RPC requests\n * @param args {@link SendTransactionParameters}\n * @param overrides optional {@link UserOperationOverrides} to use for any of the fields\n * @param context if the smart account client requires additinoal context for building UOs\n * @returns a Promise containing the built user operation\n */\nexport async function buildUserOperationFromTx<\n  TChain extends Chain | undefined = Chain | undefined,\n  TAccount extends SmartContractAccount | undefined =\n    | SmartContractAccount\n    | undefined,\n  TChainOverride extends Chain | undefined = Chain | undefined,\n  TContext extends UserOperationContext | undefined =\n    | UserOperationContext\n    | undefined,\n  TEntryPointVersion extends GetEntryPointFromAccount<TAccount> = GetEntryPointFromAccount<TAccount>\n>(\n  client: Client<Transport, TChain, TAccount>,\n  args: SendTransactionParameters<TChain, TAccount, TChainOverride>,\n  overrides?: UserOperationOverrides<TEntryPointVersion>,\n  context?: TContext\n): Promise<UserOperationStruct<TEntryPointVersion>> {\n  const { account = client.account, ...request } = args;\n  if (!account || typeof account === \"string\") {\n    throw new AccountNotFoundError();\n  }\n\n  if (!request.to) {\n    throw new TransactionMissingToParamError();\n  }\n\n  if (!isBaseSmartAccountClient(client)) {\n    throw new IncompatibleClientError(\n      \"BaseSmartAccountClient\",\n      \"buildUserOperationFromTx\",\n      client\n    );\n  }\n\n  const _overrides = {\n    ...overrides,\n    maxFeePerGas: request.maxFeePerGas ? request.maxFeePerGas : undefined,\n    maxPriorityFeePerGas: request.maxPriorityFeePerGas\n      ? request.maxPriorityFeePerGas\n      : undefined,\n  } as UserOperationOverrides<TEntryPointVersion>;\n\n  return buildUserOperation(client, {\n    uo: {\n      target: request.to,\n      data: request.data ?? \"0x\",\n      value: request.value ? request.value : 0n,\n    },\n    account: account as SmartContractAccount,\n    context,\n    overrides: _overrides,\n  });\n}\n"]}