import { getTransaction } from "viem/actions";
import { isBaseSmartAccountClient } from "../../client/isSmartAccountClient.js";
import { IncompatibleClientError } from "../../errors/client.js";
import { FailedToFindTransactionError } from "../../errors/transaction.js";
import { Logger } from "../../logger.js";
export const waitForUserOperationTransaction = async (client, args) => {
    if (!isBaseSmartAccountClient(client)) {
        throw new IncompatibleClientError("BaseSmartAccountClient", "waitForUserOperationTransaction", client);
    }
    const { hash, retries = {
        maxRetries: client.txMaxRetries,
        intervalMs: client.txRetryIntervalMs,
        multiplier: client.txRetryMultiplier,
    }, } = args;
    for (let i = 0; i < retries.maxRetries; i++) {
        const txRetryIntervalWithJitterMs = retries.intervalMs * Math.pow(retries.multiplier, i) +
            Math.random() * 100;
        await new Promise((resolve) => setTimeout(resolve, txRetryIntervalWithJitterMs));
        const receipt = await client
            .getUserOperationReceipt(hash)
            .catch((e) => {
            Logger.error(`[SmartAccountProvider] waitForUserOperationTransaction error fetching receipt for ${hash}: ${e}`);
        });
        if (receipt) {
            return getTransaction(client, {
                hash: receipt.receipt.transactionHash,
            }).then((x) => x.hash);
        }
    }
    throw new FailedToFindTransactionError(hash);
};
//# sourceMappingURL=waitForUserOperationTransacation.js.map