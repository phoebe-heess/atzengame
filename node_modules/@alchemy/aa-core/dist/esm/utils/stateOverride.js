import { AccountStateConflictError, InvalidAddressError, StateAssignmentConflictError, isAddress, numberToHex, } from "viem";
function serializeStateMapping(stateMapping) {
    if (!stateMapping || stateMapping.length === 0)
        return undefined;
    return stateMapping.reduce((acc, { slot, value }) => {
        validateBytes32HexLength(slot);
        validateBytes32HexLength(value);
        acc[slot] = value;
        return acc;
    }, {});
}
function validateBytes32HexLength(value) {
    if (value.length !== 66) {
        throw new Error(`Hex is expected to be 66 hex long, but is ${value.length} hex long.`);
    }
}
function serializeAccountStateOverride(parameters) {
    const { balance, nonce, state, stateDiff, code } = parameters;
    const rpcAccountStateOverride = {};
    if (code !== undefined)
        rpcAccountStateOverride.code = code;
    if (balance !== undefined)
        rpcAccountStateOverride.balance = numberToHex(balance);
    if (nonce !== undefined)
        rpcAccountStateOverride.nonce = numberToHex(nonce);
    if (state !== undefined)
        rpcAccountStateOverride.state = serializeStateMapping(state);
    if (stateDiff !== undefined) {
        if (rpcAccountStateOverride.state)
            throw new StateAssignmentConflictError();
        rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
    }
    return rpcAccountStateOverride;
}
export function serializeStateOverride(parameters) {
    if (!parameters)
        return undefined;
    const rpcStateOverride = {};
    for (const { address, ...accountState } of parameters) {
        if (!isAddress(address, { strict: false }))
            throw new InvalidAddressError({ address });
        if (rpcStateOverride[address])
            throw new AccountStateConflictError({ address: address });
        rpcStateOverride[address] = serializeAccountStateOverride(accountState);
    }
    return rpcStateOverride;
}
//# sourceMappingURL=stateOverride.js.map