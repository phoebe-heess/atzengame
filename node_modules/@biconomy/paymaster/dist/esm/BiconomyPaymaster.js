"use strict";import{encodeFunctionData as G,parseAbi as L}from"viem";import{PaymasterMode as f}from"./utils/Types.js";import{MAX_UINT256 as w,ERC20_ABI as k,ADDRESS_ZERO as x}from"./utils/Constants.js";import{sendRequest as A,HttpMethod as y,Logger as p}from"@biconomy/common";import{getTimestampInSeconds as g}from"./utils/Helpers.js";const I={paymasterUrl:"",strictMode:!1};export class BiconomyPaymaster{constructor(t){Object.defineProperty(this,"paymasterConfig",{enumerable:!0,configurable:!0,writable:!0,value:void 0});const e={...I,...t};this.paymasterConfig=e}async prepareUserOperation(t){const e={...t};try{const n=["nonce","maxFeePerGas","maxPriorityFeePerGas"];for(const r of n)e[r]&&e[r]!=="0x"&&(e[r]="0x"+BigInt(t[r]).toString(16));const i=["callGasLimit","verificationGasLimit","preVerificationGas"];for(const r of i)e[r]&&e[r]!=="0x"&&(e[r]=BigInt(t[r]).toString())}catch(n){throw`Failed to transform user operation: ${n}`}return e.signature=t.signature||"0x",e.paymasterAndData=t.paymasterAndData||"0x",e}async buildTokenApprovalTransaction(t){const e=t.feeQuote.tokenAddress,n=t.spender;let i=BigInt(0);t.maxApproval&&t.maxApproval==!0?i=BigInt(w):i=BigInt(Math.ceil(t.feeQuote.maxGasFee*Math.pow(10,t.feeQuote.decimal)));try{const r=L(k),s=G({abi:r,functionName:"approve",args:[n,i]});return{to:e,value:"0x00",data:s}}catch{throw new Error("Failed to encode function data")}}async getPaymasterFeeQuotesOrData(t,e){t=await this.prepareUserOperation(t);let n=null,i=null;const r=e.calculateGasLimits??!0;let s=null,c=[],l={name:"BICONOMY",version:"2.0.0"},a=null;e.mode&&(n=e.mode),e.expiryDuration&&(i=e.expiryDuration),s=e?.preferredToken?e?.preferredToken:s,c=e?.tokenList?.length!==0?e?.tokenList:c,a=e?.webhookData??a,l=e?.smartAccountInfo??l;try{const o=await A({url:`${this.paymasterConfig.paymasterUrl}`,method:y.Post,body:{method:"pm_getFeeQuoteOrData",params:[t,{...n!==null&&{mode:n},calculateGasLimits:r,...i!==null&&{expiryDuration:i},tokenInfo:{tokenList:c,...s!==null&&{preferredToken:s}},sponsorshipInfo:{...a!==null&&{webhookData:a},smartAccountInfo:l}}],id:g(),jsonrpc:"2.0"}},"Paymaster");if(o&&o.result)if(o.result.mode==f.ERC20){const d=o.result.feeQuotes,m=o.result.paymasterAddress;return{feeQuotes:d,tokenPaymasterAddress:m}}else if(o.result.mode==f.SPONSORED){const d=o.result.paymasterAndData,m=o.result.preVerificationGas,u=o.result.verificationGasLimit,h=o.result.callGasLimit;return{paymasterAndData:d,preVerificationGas:m,verificationGasLimit:u,callGasLimit:h}}else throw{code:417,message:"Expectation Failed: Invalid mode in Paymaster service response"}}catch(o){if(p.error("Failed to fetch Fee Quotes or Paymaster data - reason: ",JSON.stringify(o)),!this.paymasterConfig.strictMode&&e.mode==f.SPONSORED&&(o?.message.includes("Smart contract data not found")||o?.message.includes("No policies were set")))return p.warn(`Strict mode is ${this.paymasterConfig.strictMode}. sending paymasterAndData 0x`),{paymasterAndData:"0x",preVerificationGas:t.preVerificationGas,verificationGasLimit:t.verificationGasLimit,callGasLimit:t.callGasLimit};throw o}throw new Error("Failed to fetch feeQuote or paymaster data")}async getPaymasterAndData(t,e){if(t=await this.prepareUserOperation(t),e?.mode===void 0)throw new Error("mode is required in paymasterServiceData");const n=e.mode,i=e.calculateGasLimits??!0;let r=null,s=null,c={name:"BICONOMY",version:"2.0.0"},l=null;if(n===f.ERC20){if(!e?.feeTokenAddress&&e?.feeTokenAddress===x)throw new Error("feeTokenAddress is required and should be non-zero");r={feeTokenAddress:e.feeTokenAddress}}l=e?.webhookData??l,c=e?.smartAccountInfo??c,s=e?.expiryDuration??s;try{const a=await A({url:`${this.paymasterConfig.paymasterUrl}`,method:y.Post,body:{method:"pm_sponsorUserOperation",params:[t,{mode:n,calculateGasLimits:i,...s!==null&&{expiryDuration:s},...r!==null&&{tokenInfo:r},sponsorshipInfo:{...l!==null&&{webhookData:l},smartAccountInfo:c}}],id:g(),jsonrpc:"2.0"}},"Paymaster");if(a&&a.result){const o=a.result.paymasterAndData,d=a.result.preVerificationGas,m=a.result.verificationGasLimit,u=a.result.callGasLimit;return{paymasterAndData:o,preVerificationGas:d,verificationGasLimit:m,callGasLimit:u}}}catch(a){throw p.error("Error in generating paymasterAndData - reason: ",JSON.stringify(a)),a}throw new Error("Error in generating paymasterAndData")}async getDummyPaymasterAndData(t,e){return"0x"}static async create(t){return new BiconomyPaymaster(t)}}
