"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSigner = void 0;
const EthersSigner_js_1 = require("../EthersSigner.js");
const aa_core_1 = require("@alchemy/aa-core");
const Constants_js_1 = require("../Constants.js");
const convertSigner = async (signer, skipChainIdCalls = false) => {
    let resolvedSmartAccountSigner;
    let rpcUrl = null;
    let chainId = null;
    const isAnAlchemySigner = Constants_js_1.UNIQUE_PROPERTIES_PER_SIGNER.alchemy in signer;
    const isAnEthersSigner = Constants_js_1.UNIQUE_PROPERTIES_PER_SIGNER.ethers in signer;
    const isAViemSigner = Constants_js_1.UNIQUE_PROPERTIES_PER_SIGNER.viem in signer;
    if (!isAnAlchemySigner) {
        if (isAnEthersSigner) {
            const ethersSigner = signer;
            if (!skipChainIdCalls) {
                if (!ethersSigner.provider) {
                    throw new Error("Cannot consume an ethers Wallet without a provider");
                }
                const chainIdFromProvider = await ethersSigner.provider.getNetwork();
                if (!chainIdFromProvider?.chainId) {
                    throw new Error("Cannot consume an ethers Wallet without a chainId");
                }
                chainId = Number(chainIdFromProvider.chainId);
            }
            resolvedSmartAccountSigner = new EthersSigner_js_1.EthersSigner(ethersSigner, "ethers");
            rpcUrl = ethersSigner.provider?.connection?.url ?? null;
        }
        else if (isAViemSigner) {
            const walletClient = signer;
            if (!walletClient.account) {
                throw new Error("Cannot consume a viem wallet without an account");
            }
            if (!skipChainIdCalls) {
                if (!walletClient.chain) {
                    throw new Error("Cannot consume a viem wallet without a chainId");
                }
                chainId = walletClient.chain.id;
            }
            resolvedSmartAccountSigner = new aa_core_1.WalletClientSigner(walletClient, "viem");
            rpcUrl = walletClient?.transport?.url ?? null;
        }
        else {
            throw new Error("Unsupported signer");
        }
    }
    else {
        resolvedSmartAccountSigner = signer;
    }
    return { signer: resolvedSmartAccountSigner, rpcUrl, chainId };
};
exports.convertSigner = convertSigner;
//# sourceMappingURL=convertSigner.js.map