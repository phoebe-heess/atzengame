{"version":3,"file":"Bundler.js","sourceRoot":"","sources":["../../src/Bundler.ts"],"names":[],"mappings":"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","sourcesContent":["import { getChain, type UserOperationStruct } from \"@alchemy/aa-core\";\nimport { createPublicClient, http, PublicClient } from \"viem\";\nimport { IBundler } from \"./interfaces/IBundler.js\";\nimport {\n  GetUserOperationReceiptResponse,\n  GetUserOpByHashResponse,\n  Bundlerconfig,\n  UserOpResponse,\n  EstimateUserOpGasResponse,\n  UserOpReceipt,\n  SendUserOpResponse,\n  UserOpGasResponse,\n  UserOpByHashResponse,\n  GetGasFeeValuesResponse,\n  GasFeeValues,\n  UserOpStatus,\n  GetUserOperationStatusResponse,\n  SimulationType,\n  BundlerConfigWithChainId,\n} from \"./utils/Types.js\";\nimport { transformUserOP, getTimestampInSeconds } from \"./utils/HelperFunction.js\";\nimport {\n  UserOpReceiptIntervals,\n  UserOpWaitForTxHashIntervals,\n  UserOpWaitForTxHashMaxDurationIntervals,\n  UserOpReceiptMaxDurationIntervals,\n  DEFAULT_ENTRYPOINT_ADDRESS,\n} from \"./utils/Constants.js\";\nimport { extractChainIdFromBundlerUrl } from \"./utils/Utils.js\";\nimport { sendRequest, HttpMethod, StateOverrideSet } from \"@biconomy/common\";\n\n/**\n * This class implements IBundler interface.\n * Implementation sends UserOperation to a bundler URL as per ERC4337 standard.\n * Checkout the proposal for more details on Bundlers.\n */\nexport class Bundler implements IBundler {\n  private bundlerConfig: BundlerConfigWithChainId;\n\n  // eslint-disable-next-line no-unused-vars\n  UserOpReceiptIntervals!: { [key in number]?: number };\n\n  UserOpWaitForTxHashIntervals!: { [key in number]?: number };\n\n  UserOpReceiptMaxDurationIntervals!: { [key in number]?: number };\n\n  UserOpWaitForTxHashMaxDurationIntervals!: { [key in number]?: number };\n\n  private provider: PublicClient;\n\n  constructor(bundlerConfig: Bundlerconfig) {\n    const parsedChainId: number = bundlerConfig?.chainId || extractChainIdFromBundlerUrl(bundlerConfig.bundlerUrl);\n    this.bundlerConfig = { ...bundlerConfig, chainId: parsedChainId };\n\n    this.provider = createPublicClient({\n      chain: bundlerConfig.viemChain ?? getChain(parsedChainId),\n      transport: http((bundlerConfig.viemChain || getChain(parsedChainId)).rpcUrls.default.http[0]),\n    });\n\n    this.UserOpReceiptIntervals = {\n      ...UserOpReceiptIntervals,\n      ...bundlerConfig.userOpReceiptIntervals,\n    };\n\n    this.UserOpWaitForTxHashIntervals = {\n      ...UserOpWaitForTxHashIntervals,\n      ...bundlerConfig.userOpWaitForTxHashIntervals,\n    };\n\n    this.UserOpReceiptMaxDurationIntervals = {\n      ...UserOpReceiptMaxDurationIntervals,\n      ...bundlerConfig.userOpReceiptMaxDurationIntervals,\n    };\n\n    this.UserOpWaitForTxHashMaxDurationIntervals = {\n      ...UserOpWaitForTxHashMaxDurationIntervals,\n      ...bundlerConfig.userOpWaitForTxHashMaxDurationIntervals,\n    };\n\n    this.bundlerConfig.entryPointAddress = bundlerConfig.entryPointAddress || DEFAULT_ENTRYPOINT_ADDRESS;\n  }\n\n  public getBundlerUrl(): string {\n    return `${this.bundlerConfig.bundlerUrl}`;\n  }\n\n  /**\n   * @param userOpHash\n   * @description This function will fetch gasPrices from bundler\n   * @returns Promise<UserOpGasPricesResponse>\n   */\n  async estimateUserOpGas(userOp: UserOperationStruct, stateOverrideSet?: StateOverrideSet): Promise<UserOpGasResponse> {\n    // expected dummySig and possibly dummmy paymasterAndData should be provided by the caller\n    // bundler doesn't know account and paymaster implementation\n    userOp = transformUserOP(userOp);\n    const bundlerUrl = this.getBundlerUrl();\n\n    const response: EstimateUserOpGasResponse = await sendRequest(\n      {\n        url: bundlerUrl,\n        method: HttpMethod.Post,\n        body: {\n          method: \"eth_estimateUserOperationGas\",\n          params: stateOverrideSet\n            ? [userOp, this.bundlerConfig.entryPointAddress, stateOverrideSet]\n            : [userOp, this.bundlerConfig.entryPointAddress],\n          id: getTimestampInSeconds(),\n          jsonrpc: \"2.0\",\n        },\n      },\n      \"Bundler\",\n    );\n\n    const userOpGasResponse = response.result;\n    for (const key in userOpGasResponse) {\n      if (key === \"maxFeePerGas\" || key === \"maxPriorityFeePerGas\") continue;\n      if (userOpGasResponse[key as keyof UserOpGasResponse] === undefined || userOpGasResponse[key as keyof UserOpGasResponse] === null) {\n        throw new Error(`Got undefined ${key} from bundler`);\n      }\n    }\n    return userOpGasResponse;\n  }\n\n  /**\n   *\n   * @param userOp\n   * @description This function will send signed userOp to bundler to get mined on chain\n   * @returns Promise<UserOpResponse>\n   */\n  async sendUserOp(userOp: UserOperationStruct, simulationParam?: SimulationType): Promise<UserOpResponse> {\n    const chainId = this.bundlerConfig.chainId;\n    // transformUserOP will convert all bigNumber values to string\n    userOp = transformUserOP(userOp);\n    const simType = {\n      simulation_type: simulationParam || \"validation\",\n    };\n    const params = [userOp, this.bundlerConfig.entryPointAddress, simType];\n    const bundlerUrl = this.getBundlerUrl();\n    const sendUserOperationResponse: SendUserOpResponse = await sendRequest(\n      {\n        url: bundlerUrl,\n        method: HttpMethod.Post,\n        body: {\n          method: \"eth_sendUserOperation\",\n          params: params,\n          id: getTimestampInSeconds(),\n          jsonrpc: \"2.0\",\n        },\n      },\n      \"Bundler\",\n    );\n    const response: UserOpResponse = {\n      userOpHash: sendUserOperationResponse.result,\n      wait: (confirmations?: number): Promise<UserOpReceipt> => {\n        // Note: maxDuration can be defined per chainId\n        const maxDuration = this.UserOpReceiptMaxDurationIntervals[chainId] || 30000; // default 30 seconds\n        let totalDuration = 0;\n\n        return new Promise<UserOpReceipt>((resolve, reject) => {\n          const intervalValue = this.UserOpReceiptIntervals[chainId] || 5000; // default 5 seconds\n          const intervalId = setInterval(async () => {\n            try {\n              const userOpResponse = await this.getUserOpReceipt(sendUserOperationResponse.result);\n              if (userOpResponse && userOpResponse.receipt && userOpResponse.receipt.blockNumber) {\n                if (confirmations) {\n                  const latestBlock = await this.provider.getBlockNumber();\n                  const confirmedBlocks = Number(latestBlock) - userOpResponse.receipt.blockNumber;\n                  if (confirmations >= confirmedBlocks) {\n                    clearInterval(intervalId);\n                    resolve(userOpResponse);\n                    return;\n                  }\n                } else {\n                  clearInterval(intervalId);\n                  resolve(userOpResponse);\n                  return;\n                }\n              }\n            } catch (error) {\n              clearInterval(intervalId);\n              reject(error);\n              return;\n            }\n\n            totalDuration += intervalValue;\n            if (totalDuration >= maxDuration) {\n              clearInterval(intervalId);\n              reject(\n                new Error(\n                  `Exceeded maximum duration (${maxDuration / 1000} sec) waiting to get receipt for userOpHash ${\n                    sendUserOperationResponse.result\n                  }. Try getting the receipt manually using eth_getUserOperationReceipt rpc method on bundler`,\n                ),\n              );\n            }\n          }, intervalValue);\n        });\n      },\n      waitForTxHash: (): Promise<UserOpStatus> => {\n        const maxDuration = this.UserOpWaitForTxHashMaxDurationIntervals[chainId] || 20000; // default 20 seconds\n        let totalDuration = 0;\n\n        return new Promise<UserOpStatus>((resolve, reject) => {\n          const intervalValue = this.UserOpWaitForTxHashIntervals[chainId] || 500; // default 0.5 seconds\n          const intervalId = setInterval(async () => {\n            try {\n              const userOpStatus = await this.getUserOpStatus(sendUserOperationResponse.result);\n              if (userOpStatus && userOpStatus.state && userOpStatus.transactionHash) {\n                clearInterval(intervalId);\n                resolve(userOpStatus);\n                return;\n              }\n            } catch (error) {\n              clearInterval(intervalId);\n              reject(error);\n              return;\n            }\n\n            totalDuration += intervalValue;\n            if (totalDuration >= maxDuration) {\n              clearInterval(intervalId);\n              reject(\n                new Error(\n                  `Exceeded maximum duration (${maxDuration / 1000} sec) waiting to get receipt for userOpHash ${\n                    sendUserOperationResponse.result\n                  }. Try getting the receipt manually using eth_getUserOperationReceipt rpc method on bundler`,\n                ),\n              );\n            }\n          }, intervalValue);\n        });\n      },\n    };\n    return response;\n  }\n\n  /**\n   *\n   * @param userOpHash\n   * @description This function will return userOpReceipt for a given userOpHash\n   * @returns Promise<UserOpReceipt>\n   */\n  async getUserOpReceipt(userOpHash: string): Promise<UserOpReceipt> {\n    const bundlerUrl = this.getBundlerUrl();\n    const response: GetUserOperationReceiptResponse = await sendRequest(\n      {\n        url: bundlerUrl,\n        method: HttpMethod.Post,\n        body: {\n          method: \"eth_getUserOperationReceipt\",\n          params: [userOpHash],\n          id: getTimestampInSeconds(),\n          jsonrpc: \"2.0\",\n        },\n      },\n      \"Bundler\",\n    );\n    const userOpReceipt: UserOpReceipt = response.result;\n    return userOpReceipt;\n  }\n\n  /**\n   *\n   * @param userOpHash\n   * @description This function will return userOpReceipt for a given userOpHash\n   * @returns Promise<UserOpReceipt>\n   */\n  async getUserOpStatus(userOpHash: string): Promise<UserOpStatus> {\n    const bundlerUrl = this.getBundlerUrl();\n    const response: GetUserOperationStatusResponse = await sendRequest(\n      {\n        url: bundlerUrl,\n        method: HttpMethod.Post,\n        body: {\n          method: \"biconomy_getUserOperationStatus\",\n          params: [userOpHash],\n          id: getTimestampInSeconds(),\n          jsonrpc: \"2.0\",\n        },\n      },\n      \"Bundler\",\n    );\n    const userOpStatus: UserOpStatus = response.result;\n    return userOpStatus;\n  }\n\n  /**\n   *\n   * @param userOpHash\n   * @description this function will return UserOpByHashResponse for given UserOpHash\n   * @returns Promise<UserOpByHashResponse>\n   */\n  async getUserOpByHash(userOpHash: string): Promise<UserOpByHashResponse> {\n    const bundlerUrl = this.getBundlerUrl();\n    const response: GetUserOpByHashResponse = await sendRequest(\n      {\n        url: bundlerUrl,\n        method: HttpMethod.Post,\n        body: {\n          method: \"eth_getUserOperationByHash\",\n          params: [userOpHash],\n          id: getTimestampInSeconds(),\n          jsonrpc: \"2.0\",\n        },\n      },\n      \"Bundler\",\n    );\n    const userOpByHashResponse: UserOpByHashResponse = response.result;\n    return userOpByHashResponse;\n  }\n\n  /**\n   * @description This function will return the gas fee values\n   */\n  async getGasFeeValues(): Promise<GasFeeValues> {\n    const bundlerUrl = this.getBundlerUrl();\n    const response: GetGasFeeValuesResponse = await sendRequest(\n      {\n        url: bundlerUrl,\n        method: HttpMethod.Post,\n        body: {\n          method: \"biconomy_getGasFeeValues\",\n          params: [],\n          id: getTimestampInSeconds(),\n          jsonrpc: \"2.0\",\n        },\n      },\n      \"Bundler\",\n    );\n    return response.result;\n  }\n\n  public static async create(config: Bundlerconfig): Promise<Bundler> {\n    return new Bundler(config);\n  }\n}\n"]}