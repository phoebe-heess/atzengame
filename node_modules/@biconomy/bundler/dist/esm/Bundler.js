"use strict";import{getChain as O}from"@alchemy/aa-core";import{createPublicClient as f,http as x}from"viem";import{transformUserOP as y,getTimestampInSeconds as l}from"./utils/HelperFunction.js";import{UserOpReceiptIntervals as w,UserOpWaitForTxHashIntervals as P,UserOpWaitForTxHashMaxDurationIntervals as R,UserOpReceiptMaxDurationIntervals as B,DEFAULT_ENTRYPOINT_ADDRESS as H}from"./utils/Constants.js";import{extractChainIdFromBundlerUrl as T}from"./utils/Utils.js";import{sendRequest as u,HttpMethod as p}from"@biconomy/common";export class Bundler{constructor(e){Object.defineProperty(this,"bundlerConfig",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"UserOpReceiptIntervals",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"UserOpWaitForTxHashIntervals",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"UserOpReceiptMaxDurationIntervals",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"UserOpWaitForTxHashMaxDurationIntervals",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"provider",{enumerable:!0,configurable:!0,writable:!0,value:void 0});const t=e?.chainId||T(e.bundlerUrl);this.bundlerConfig={...e,chainId:t},this.provider=f({chain:e.viemChain??O(t),transport:x((e.viemChain||O(t)).rpcUrls.default.http[0])}),this.UserOpReceiptIntervals={...w,...e.userOpReceiptIntervals},this.UserOpWaitForTxHashIntervals={...P,...e.userOpWaitForTxHashIntervals},this.UserOpReceiptMaxDurationIntervals={...B,...e.userOpReceiptMaxDurationIntervals},this.UserOpWaitForTxHashMaxDurationIntervals={...R,...e.userOpWaitForTxHashMaxDurationIntervals},this.bundlerConfig.entryPointAddress=e.entryPointAddress||H}getBundlerUrl(){return`${this.bundlerConfig.bundlerUrl}`}async estimateUserOpGas(e,t){e=y(e);const s=this.getBundlerUrl(),i=(await u({url:s,method:p.Post,body:{method:"eth_estimateUserOperationGas",params:t?[e,this.bundlerConfig.entryPointAddress,t]:[e,this.bundlerConfig.entryPointAddress],id:l(),jsonrpc:"2.0"}},"Bundler")).result;for(const a in i)if(!(a==="maxFeePerGas"||a==="maxPriorityFeePerGas")&&(i[a]===void 0||i[a]===null))throw new Error(`Got undefined ${a} from bundler`);return i}async sendUserOp(e,t){const s=this.bundlerConfig.chainId;e=y(e);const c={simulation_type:t||"validation"},i=[e,this.bundlerConfig.entryPointAddress,c],a=this.getBundlerUrl(),d=await u({url:a,method:p.Post,body:{method:"eth_sendUserOperation",params:i,id:l(),jsonrpc:"2.0"}},"Bundler");return{userOpHash:d.result,wait:h=>{const m=this.UserOpReceiptMaxDurationIntervals[s]||3e4;let v=0;return new Promise((U,b)=>{const o=this.UserOpReceiptIntervals[s]||5e3,r=setInterval(async()=>{try{const n=await this.getUserOpReceipt(d.result);if(n&&n.receipt&&n.receipt.blockNumber)if(h){const I=await this.provider.getBlockNumber(),g=Number(I)-n.receipt.blockNumber;if(h>=g){clearInterval(r),U(n);return}}else{clearInterval(r),U(n);return}}catch(n){clearInterval(r),b(n);return}v+=o,v>=m&&(clearInterval(r),b(new Error(`Exceeded maximum duration (${m/1e3} sec) waiting to get receipt for userOpHash ${d.result}. Try getting the receipt manually using eth_getUserOperationReceipt rpc method on bundler`)))},o)})},waitForTxHash:()=>{const h=this.UserOpWaitForTxHashMaxDurationIntervals[s]||2e4;let m=0;return new Promise((v,U)=>{const b=this.UserOpWaitForTxHashIntervals[s]||500,o=setInterval(async()=>{try{const r=await this.getUserOpStatus(d.result);if(r&&r.state&&r.transactionHash){clearInterval(o),v(r);return}}catch(r){clearInterval(o),U(r);return}m+=b,m>=h&&(clearInterval(o),U(new Error(`Exceeded maximum duration (${h/1e3} sec) waiting to get receipt for userOpHash ${d.result}. Try getting the receipt manually using eth_getUserOperationReceipt rpc method on bundler`)))},b)})}}}async getUserOpReceipt(e){const t=this.getBundlerUrl();return(await u({url:t,method:p.Post,body:{method:"eth_getUserOperationReceipt",params:[e],id:l(),jsonrpc:"2.0"}},"Bundler")).result}async getUserOpStatus(e){const t=this.getBundlerUrl();return(await u({url:t,method:p.Post,body:{method:"biconomy_getUserOperationStatus",params:[e],id:l(),jsonrpc:"2.0"}},"Bundler")).result}async getUserOpByHash(e){const t=this.getBundlerUrl();return(await u({url:t,method:p.Post,body:{method:"eth_getUserOperationByHash",params:[e],id:l(),jsonrpc:"2.0"}},"Bundler")).result}async getGasFeeValues(){const e=this.getBundlerUrl();return(await u({url:e,method:p.Post,body:{method:"biconomy_getGasFeeValues",params:[],id:l(),jsonrpc:"2.0"}},"Bundler")).result}static async create(e){return new Bundler(e)}}
