import {
  HttpMethod,
  getChain,
  sendRequest
} from "./chunk-5NYPIR6L.js";
import "./chunk-6TWSTBQQ.js";
import "./chunk-25IKUNVQ.js";
import "./chunk-MPYTE4RD.js";
import {
  createPublicClient,
  http
} from "./chunk-7E4YJ4NV.js";
import "./chunk-D33J42KB.js";
import "./chunk-BNPGSSLG.js";
import "./chunk-PZ6IEZUM.js";
import {
  init_buffer,
  init_define_process_env,
  init_process
} from "./chunk-QLUQGYON.js";

// node_modules/@biconomy/bundler/dist/esm/index.js
init_define_process_env();
init_process();
init_buffer();

// node_modules/@biconomy/bundler/dist/esm/Bundler.js
init_define_process_env();
init_process();
init_buffer();

// node_modules/@biconomy/bundler/dist/esm/utils/HelperFunction.js
init_define_process_env();
init_process();
init_buffer();
var transformUserOP = (e) => {
  try {
    const r = { ...e }, o = ["nonce", "callGasLimit", "verificationGasLimit", "preVerificationGas", "maxFeePerGas", "maxPriorityFeePerGas"];
    for (const t of o)
      r[t] && r[t] !== "0x" && (r[t] = "0x" + BigInt(e[t]).toString(16));
    return r;
  } catch (r) {
    throw `Failed to transform user operation: ${r}`;
  }
};
var getTimestampInSeconds = () => Math.floor(Date.now() / 1e3);

// node_modules/@biconomy/bundler/dist/esm/utils/Constants.js
init_define_process_env();
init_process();
init_buffer();
var UserOpReceiptIntervals = { 1: 1e4 };
var UserOpWaitForTxHashIntervals = { 1: 1e3 };
var UserOpReceiptMaxDurationIntervals = { 1: 3e5, 80001: 5e4, 137: 6e4, 56: 5e4, 97: 5e4, 421613: 5e4, 42161: 5e4, 59140: 5e4 };
var UserOpWaitForTxHashMaxDurationIntervals = { 1: 2e4 };
var DEFAULT_ENTRYPOINT_ADDRESS = "0x5ff137d4b0fdcd49dca30c7cf57e578a026d2789";

// node_modules/@biconomy/bundler/dist/esm/utils/Utils.js
init_define_process_env();
init_process();
init_buffer();
var extractChainIdFromBundlerUrl = (e) => {
  try {
    const r = /\/api\/v2\/(\d+)\/[a-zA-Z0-9.-]+$/.exec(e);
    return parseInt(r[1]);
  } catch {
    throw new Error("Invalid chain id");
  }
};
var extractChainIdFromPaymasterUrl = (e) => {
  try {
    const r = /\/api\/v\d+\/(\d+)\//.exec(e);
    if (!r)
      throw new Error("Invalid URL format");
    return parseInt(r[1]);
  } catch {
    throw new Error("Invalid chain id");
  }
};

// node_modules/@biconomy/bundler/dist/esm/Bundler.js
var Bundler = class _Bundler {
  constructor(e) {
    Object.defineProperty(this, "bundlerConfig", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "UserOpReceiptIntervals", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "UserOpWaitForTxHashIntervals", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "UserOpReceiptMaxDurationIntervals", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "UserOpWaitForTxHashMaxDurationIntervals", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "provider", { enumerable: true, configurable: true, writable: true, value: void 0 });
    const t = (e == null ? void 0 : e.chainId) || extractChainIdFromBundlerUrl(e.bundlerUrl);
    this.bundlerConfig = { ...e, chainId: t }, this.provider = createPublicClient({ chain: e.viemChain ?? getChain(t), transport: http((e.viemChain || getChain(t)).rpcUrls.default.http[0]) }), this.UserOpReceiptIntervals = { ...UserOpReceiptIntervals, ...e.userOpReceiptIntervals }, this.UserOpWaitForTxHashIntervals = { ...UserOpWaitForTxHashIntervals, ...e.userOpWaitForTxHashIntervals }, this.UserOpReceiptMaxDurationIntervals = { ...UserOpReceiptMaxDurationIntervals, ...e.userOpReceiptMaxDurationIntervals }, this.UserOpWaitForTxHashMaxDurationIntervals = { ...UserOpWaitForTxHashMaxDurationIntervals, ...e.userOpWaitForTxHashMaxDurationIntervals }, this.bundlerConfig.entryPointAddress = e.entryPointAddress || DEFAULT_ENTRYPOINT_ADDRESS;
  }
  getBundlerUrl() {
    return `${this.bundlerConfig.bundlerUrl}`;
  }
  async estimateUserOpGas(e, t) {
    e = transformUserOP(e);
    const s = this.getBundlerUrl(), i = (await sendRequest({ url: s, method: HttpMethod.Post, body: { method: "eth_estimateUserOperationGas", params: t ? [e, this.bundlerConfig.entryPointAddress, t] : [e, this.bundlerConfig.entryPointAddress], id: getTimestampInSeconds(), jsonrpc: "2.0" } }, "Bundler")).result;
    for (const a in i)
      if (!(a === "maxFeePerGas" || a === "maxPriorityFeePerGas") && (i[a] === void 0 || i[a] === null))
        throw new Error(`Got undefined ${a} from bundler`);
    return i;
  }
  async sendUserOp(e, t) {
    const s = this.bundlerConfig.chainId;
    e = transformUserOP(e);
    const c = { simulation_type: t || "validation" }, i = [e, this.bundlerConfig.entryPointAddress, c], a = this.getBundlerUrl(), d = await sendRequest({ url: a, method: HttpMethod.Post, body: { method: "eth_sendUserOperation", params: i, id: getTimestampInSeconds(), jsonrpc: "2.0" } }, "Bundler");
    return { userOpHash: d.result, wait: (h) => {
      const m = this.UserOpReceiptMaxDurationIntervals[s] || 3e4;
      let v = 0;
      return new Promise((U, b) => {
        const o = this.UserOpReceiptIntervals[s] || 5e3, r = setInterval(async () => {
          try {
            const n = await this.getUserOpReceipt(d.result);
            if (n && n.receipt && n.receipt.blockNumber)
              if (h) {
                const I = await this.provider.getBlockNumber(), g = Number(I) - n.receipt.blockNumber;
                if (h >= g) {
                  clearInterval(r), U(n);
                  return;
                }
              } else {
                clearInterval(r), U(n);
                return;
              }
          } catch (n) {
            clearInterval(r), b(n);
            return;
          }
          v += o, v >= m && (clearInterval(r), b(new Error(`Exceeded maximum duration (${m / 1e3} sec) waiting to get receipt for userOpHash ${d.result}. Try getting the receipt manually using eth_getUserOperationReceipt rpc method on bundler`)));
        }, o);
      });
    }, waitForTxHash: () => {
      const h = this.UserOpWaitForTxHashMaxDurationIntervals[s] || 2e4;
      let m = 0;
      return new Promise((v, U) => {
        const b = this.UserOpWaitForTxHashIntervals[s] || 500, o = setInterval(async () => {
          try {
            const r = await this.getUserOpStatus(d.result);
            if (r && r.state && r.transactionHash) {
              clearInterval(o), v(r);
              return;
            }
          } catch (r) {
            clearInterval(o), U(r);
            return;
          }
          m += b, m >= h && (clearInterval(o), U(new Error(`Exceeded maximum duration (${h / 1e3} sec) waiting to get receipt for userOpHash ${d.result}. Try getting the receipt manually using eth_getUserOperationReceipt rpc method on bundler`)));
        }, b);
      });
    } };
  }
  async getUserOpReceipt(e) {
    const t = this.getBundlerUrl();
    return (await sendRequest({ url: t, method: HttpMethod.Post, body: { method: "eth_getUserOperationReceipt", params: [e], id: getTimestampInSeconds(), jsonrpc: "2.0" } }, "Bundler")).result;
  }
  async getUserOpStatus(e) {
    const t = this.getBundlerUrl();
    return (await sendRequest({ url: t, method: HttpMethod.Post, body: { method: "biconomy_getUserOperationStatus", params: [e], id: getTimestampInSeconds(), jsonrpc: "2.0" } }, "Bundler")).result;
  }
  async getUserOpByHash(e) {
    const t = this.getBundlerUrl();
    return (await sendRequest({ url: t, method: HttpMethod.Post, body: { method: "eth_getUserOperationByHash", params: [e], id: getTimestampInSeconds(), jsonrpc: "2.0" } }, "Bundler")).result;
  }
  async getGasFeeValues() {
    const e = this.getBundlerUrl();
    return (await sendRequest({ url: e, method: HttpMethod.Post, body: { method: "biconomy_getGasFeeValues", params: [], id: getTimestampInSeconds(), jsonrpc: "2.0" } }, "Bundler")).result;
  }
  static async create(e) {
    return new _Bundler(e);
  }
};

// node_modules/@biconomy/bundler/dist/esm/interfaces/IBundler.js
init_define_process_env();
init_process();
init_buffer();

// node_modules/@biconomy/bundler/dist/esm/utils/Types.js
init_define_process_env();
init_process();
init_buffer();

// node_modules/@biconomy/bundler/dist/esm/index.js
var createBundler = Bundler.create;
export {
  Bundler,
  createBundler,
  extractChainIdFromBundlerUrl,
  extractChainIdFromPaymasterUrl
};
//# sourceMappingURL=@biconomy_bundler.js.map
