import {
  HttpMethod,
  sendRequest,
  t
} from "./chunk-5NYPIR6L.js";
import "./chunk-6TWSTBQQ.js";
import "./chunk-25IKUNVQ.js";
import "./chunk-MPYTE4RD.js";
import "./chunk-7E4YJ4NV.js";
import "./chunk-D33J42KB.js";
import {
  encodeFunctionData,
  parseAbi
} from "./chunk-BNPGSSLG.js";
import "./chunk-PZ6IEZUM.js";
import {
  init_buffer,
  init_define_process_env,
  init_process
} from "./chunk-QLUQGYON.js";

// node_modules/@biconomy/paymaster/dist/esm/index.js
init_define_process_env();
init_process();
init_buffer();

// node_modules/@biconomy/paymaster/dist/esm/BiconomyPaymaster.js
init_define_process_env();
init_process();
init_buffer();

// node_modules/@biconomy/paymaster/dist/esm/utils/Types.js
init_define_process_env();
init_process();
init_buffer();
var PaymasterMode;
(function(E) {
  E.ERC20 = "ERC20", E.SPONSORED = "SPONSORED";
})(PaymasterMode || (PaymasterMode = {}));

// node_modules/@biconomy/paymaster/dist/esm/utils/Constants.js
init_define_process_env();
init_process();
init_buffer();
var MAX_UINT256 = "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
var ADDRESS_ZERO = "0x0000000000000000000000000000000000000000";
var ERC20_ABI = ["function transfer(address to, uint256 value) external returns (bool)", "function transferFrom(address from, address to, uint256 value) external returns (bool)", "function approve(address spender, uint256 value) external returns (bool)", "function allowance(address owner, address spender) external view returns (uint256)", "function balanceOf(address owner) external view returns (uint256)"];

// node_modules/@biconomy/paymaster/dist/esm/utils/Helpers.js
init_define_process_env();
init_process();
init_buffer();
var getTimestampInSeconds = () => Math.floor(Date.now() / 1e3);

// node_modules/@biconomy/paymaster/dist/esm/BiconomyPaymaster.js
var I = { paymasterUrl: "", strictMode: false };
var BiconomyPaymaster = class _BiconomyPaymaster {
  constructor(t2) {
    Object.defineProperty(this, "paymasterConfig", { enumerable: true, configurable: true, writable: true, value: void 0 });
    const e = { ...I, ...t2 };
    this.paymasterConfig = e;
  }
  async prepareUserOperation(t2) {
    const e = { ...t2 };
    try {
      const n = ["nonce", "maxFeePerGas", "maxPriorityFeePerGas"];
      for (const r of n)
        e[r] && e[r] !== "0x" && (e[r] = "0x" + BigInt(t2[r]).toString(16));
      const i = ["callGasLimit", "verificationGasLimit", "preVerificationGas"];
      for (const r of i)
        e[r] && e[r] !== "0x" && (e[r] = BigInt(t2[r]).toString());
    } catch (n) {
      throw `Failed to transform user operation: ${n}`;
    }
    return e.signature = t2.signature || "0x", e.paymasterAndData = t2.paymasterAndData || "0x", e;
  }
  async buildTokenApprovalTransaction(t2) {
    const e = t2.feeQuote.tokenAddress, n = t2.spender;
    let i = BigInt(0);
    t2.maxApproval && t2.maxApproval == true ? i = BigInt(MAX_UINT256) : i = BigInt(Math.ceil(t2.feeQuote.maxGasFee * Math.pow(10, t2.feeQuote.decimal)));
    try {
      const r = parseAbi(ERC20_ABI), s = encodeFunctionData({ abi: r, functionName: "approve", args: [n, i] });
      return { to: e, value: "0x00", data: s };
    } catch {
      throw new Error("Failed to encode function data");
    }
  }
  async getPaymasterFeeQuotesOrData(t2, e) {
    var _a;
    t2 = await this.prepareUserOperation(t2);
    let n = null, i = null;
    const r = e.calculateGasLimits ?? true;
    let s = null, c = [], l = { name: "BICONOMY", version: "2.0.0" }, a = null;
    e.mode && (n = e.mode), e.expiryDuration && (i = e.expiryDuration), s = (e == null ? void 0 : e.preferredToken) ? e == null ? void 0 : e.preferredToken : s, c = ((_a = e == null ? void 0 : e.tokenList) == null ? void 0 : _a.length) !== 0 ? e == null ? void 0 : e.tokenList : c, a = (e == null ? void 0 : e.webhookData) ?? a, l = (e == null ? void 0 : e.smartAccountInfo) ?? l;
    try {
      const o = await sendRequest({ url: `${this.paymasterConfig.paymasterUrl}`, method: HttpMethod.Post, body: { method: "pm_getFeeQuoteOrData", params: [t2, { ...n !== null && { mode: n }, calculateGasLimits: r, ...i !== null && { expiryDuration: i }, tokenInfo: { tokenList: c, ...s !== null && { preferredToken: s } }, sponsorshipInfo: { ...a !== null && { webhookData: a }, smartAccountInfo: l } }], id: getTimestampInSeconds(), jsonrpc: "2.0" } }, "Paymaster");
      if (o && o.result)
        if (o.result.mode == PaymasterMode.ERC20) {
          const d = o.result.feeQuotes, m = o.result.paymasterAddress;
          return { feeQuotes: d, tokenPaymasterAddress: m };
        } else if (o.result.mode == PaymasterMode.SPONSORED) {
          const d = o.result.paymasterAndData, m = o.result.preVerificationGas, u = o.result.verificationGasLimit, h = o.result.callGasLimit;
          return { paymasterAndData: d, preVerificationGas: m, verificationGasLimit: u, callGasLimit: h };
        } else
          throw { code: 417, message: "Expectation Failed: Invalid mode in Paymaster service response" };
    } catch (o) {
      if (t.error("Failed to fetch Fee Quotes or Paymaster data - reason: ", JSON.stringify(o)), !this.paymasterConfig.strictMode && e.mode == PaymasterMode.SPONSORED && ((o == null ? void 0 : o.message.includes("Smart contract data not found")) || (o == null ? void 0 : o.message.includes("No policies were set"))))
        return t.warn(`Strict mode is ${this.paymasterConfig.strictMode}. sending paymasterAndData 0x`), { paymasterAndData: "0x", preVerificationGas: t2.preVerificationGas, verificationGasLimit: t2.verificationGasLimit, callGasLimit: t2.callGasLimit };
      throw o;
    }
    throw new Error("Failed to fetch feeQuote or paymaster data");
  }
  async getPaymasterAndData(t2, e) {
    if (t2 = await this.prepareUserOperation(t2), (e == null ? void 0 : e.mode) === void 0)
      throw new Error("mode is required in paymasterServiceData");
    const n = e.mode, i = e.calculateGasLimits ?? true;
    let r = null, s = null, c = { name: "BICONOMY", version: "2.0.0" }, l = null;
    if (n === PaymasterMode.ERC20) {
      if (!(e == null ? void 0 : e.feeTokenAddress) && (e == null ? void 0 : e.feeTokenAddress) === ADDRESS_ZERO)
        throw new Error("feeTokenAddress is required and should be non-zero");
      r = { feeTokenAddress: e.feeTokenAddress };
    }
    l = (e == null ? void 0 : e.webhookData) ?? l, c = (e == null ? void 0 : e.smartAccountInfo) ?? c, s = (e == null ? void 0 : e.expiryDuration) ?? s;
    try {
      const a = await sendRequest({ url: `${this.paymasterConfig.paymasterUrl}`, method: HttpMethod.Post, body: { method: "pm_sponsorUserOperation", params: [t2, { mode: n, calculateGasLimits: i, ...s !== null && { expiryDuration: s }, ...r !== null && { tokenInfo: r }, sponsorshipInfo: { ...l !== null && { webhookData: l }, smartAccountInfo: c } }], id: getTimestampInSeconds(), jsonrpc: "2.0" } }, "Paymaster");
      if (a && a.result) {
        const o = a.result.paymasterAndData, d = a.result.preVerificationGas, m = a.result.verificationGasLimit, u = a.result.callGasLimit;
        return { paymasterAndData: o, preVerificationGas: d, verificationGasLimit: m, callGasLimit: u };
      }
    } catch (a) {
      throw t.error("Error in generating paymasterAndData - reason: ", JSON.stringify(a)), a;
    }
    throw new Error("Error in generating paymasterAndData");
  }
  async getDummyPaymasterAndData(t2, e) {
    return "0x";
  }
  static async create(t2) {
    return new _BiconomyPaymaster(t2);
  }
};

// node_modules/@biconomy/paymaster/dist/esm/interfaces/IPaymaster.js
init_define_process_env();
init_process();
init_buffer();

// node_modules/@biconomy/paymaster/dist/esm/interfaces/IHybridPaymaster.js
init_define_process_env();
init_process();
init_buffer();

// node_modules/@biconomy/paymaster/dist/esm/index.js
var Paymaster = BiconomyPaymaster;
var createPaymaster = Paymaster.create;
export {
  BiconomyPaymaster,
  Paymaster,
  PaymasterMode,
  createPaymaster
};
//# sourceMappingURL=@biconomy_paymaster.js.map
